[{"title":"Hexo配置Waline评论系统","url":"/2023/05/27/Hexo%E9%85%8D%E7%BD%AEWaline%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/","content":"评论系统选择Waline 是一款简洁、安全的评论系统。\n具有管理评论和Reaction的功能。如图：\n\n\nHexo-Keep主题配置Waline评论系统根据 Waline 文档部署 LeanCloud 数据库和 Vercel 服务端https://waline.js.org/guide/get-started/ \n修改主题配置文件 _config.yml\n启用评论，并使用 waline 评论系统\ncomment:  enable: true   # Option values: true | false  use: waline     # Option values: valine | gitalk | twikoo | waline\n\n配置 waline\nserver_url 是成功部署 Waline 评论系统的服务端地址。\nreaction 设置开启文章反应，可选值：true 或 false。\nversion 设置 Waline 评论系统版本，Keep 主题内置使用 Waline v2，你可以自行更改。\nwaline:  server_url: https://comment-waline-server-qk96wik8t-miykah.vercel.app/ # Server URL  reaction: true # Article reactions, Option values: true | false  version: 2      # Waline version, default use v2\n\n评论系统启用成功\n\n\n\n评论系统与管理系统\n评论系统：example.yourdomain.com      我的：https://comment.miykah.top/ \n评论管理：example.yourdomain.com&#x2F;ui   我的：https://comment.miykah.top/ui \n\n评论管理系统可以进行评论管理以及用户管理：\n\n\n\n问题只有在挂了梯子之后才能流畅访问\n不连接梯子的情况下， 博客的评论一直加载不出来，百度了一下，发现是 vercel.app 的域名问题。\nhttps://blog.csdn.net/Panzer_Jack/article/details/127418379 \n\n解决办法\n参考：\nhttps://blog.csdn.net/Panzer_Jack/article/details/127418379 \nhttps://waline.js.org/guide/get-started/#%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D-%E5%8F%AF%E9%80%89 \n\n\n首先需要有一个域名，比如我有一个 miykah.top 域名\n\n域名解析添加记录：取一个二级域名为 comment ，记录值为 cname.vercel-dns.com \n\n\n在vercel部署的服务端中绑定域名 comment.miykah.top\n\n\n\n修改主题配置文件 _config.yml\nwaline:  server_url: https://comment.miykah.top/ # 改为绑定的评论系统新域名  reaction: true # Article reactions, Option values: true | false  version: 2      # Waline version, default use v2\n\n问题解决！不挂梯子也能加载出评论！\n\n\n进阶配置邮件通知参考：\nhttps://waline.js.org/guide/features/notification.html#%E9%82%AE%E4%BB%B6%E9%80%9A%E7%9F%A5 \nhttps://oragekk.me/blog/waline-mail.html \n","categories":["博客搭建"],"tags":["waline","Hexo"]},{"title":"Redis在项目中的应用","url":"/2023/05/29/Redis%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/","content":"\n本文是对黑马点评项目中 Redis的部分应用的总结：\n\n使用 Redis 代替 session 实现短信登录\n查询添加缓存，理解缓存击穿、缓存穿透和缓存雪崩及对应的解决方案\n实现全局唯一ID，实现秒杀下单解决超卖问题，解决秒杀一人一单问题\n使用 Redis 实现分布式锁\n使用基于Redis 的消息队列实现秒杀优化，完成异步秒杀\n\n\n短信登录基于 Session 实现短信登录业务逻辑发送验证码：\n用户在提交手机号后，会校验手机号是否合法，如果不合法，则要求用户重新输入手机号。\n如果手机号合法，后台此时生成对应的验证码，同时将验证码进行保存，然后再通过短信的方式将验证码发送给用户。\n短信验证码登录、注册：\n用户将验证码和手机号进行输入，后台从session中拿到当前验证码，然后和用户输入的验证码进行校验，如果不一致，则无法通过校验，如果一致，则后台根据手机号查询用户，如果用户不存在，则为用户创建账号信息，保存到数据库，无论是否存在，都会将用户信息保存到session中，方便后续获得当前登录信息。\n校验登录状态:\n用户在请求时候，会从cookie中携带sessionId到后台，后台通过sessionId从session中拿到用户信息，如果没有session信息，则进行拦截，如果有session信息，则将用户信息保存到threadLocal中，并且放行。\n\n发送短信验证码及登录功能\n发送短信验证码\n\n@Override   public Result sendCode(String phone, HttpSession session) &#123;       // 1.校验手机号       if (RegexUtils.isPhoneInvalid(phone)) &#123;           // 2.如果不符合，返回错误信息           return Result.fail(&quot;手机号格式错误！&quot;);       &#125;       // 3.符合，生成验证码       String code = RandomUtil.randomNumbers(6);       // 4.保存验证码到 session       session.setAttribute(&quot;code&quot;,code);       // 5.发送验证码       // TODO 暂时不做 要调用第三方平台 这里只是记录一下日志       log.debug(&quot;发送短信验证码成功，验证码：&#123;&#125;&quot;, code);       // 返回ok       return Result.ok();   &#125;\n\n\n登录\n\n@Overridepublic Result login(LoginFormDTO loginForm, HttpSession session) &#123;    // 1.校验手机号    String phone = loginForm.getPhone();    if (RegexUtils.isPhoneInvalid(phone)) &#123;        // 2.如果不符合，返回错误信息        return Result.fail(&quot;手机号格式错误！&quot;);    &#125;    // 3.校验验证码    Object cacheCode = session.getAttribute(&quot;code&quot;);    String code = loginForm.getCode();    if(cacheCode == null || !cacheCode.toString().equals(code))&#123;         //3.不一致，报错        return Result.fail(&quot;验证码错误&quot;);    &#125;    //一致，根据手机号查询用户    User user = query().eq(&quot;phone&quot;, phone).one();    //5.判断用户是否存在    if(user == null)&#123;        //不存在，则创建        user =  createUserWithPhone(phone);        save(user);    &#125;    //7.保存用户信息到session中    // 将User转换为UserDTO，信息脱敏    session.setAttribute(&quot;user&quot;, BeanUtils.copyProperties(user,UserDTO.class));    return Result.ok();&#125;\n\n实现登录拦截功能\n系统中进行操作前，需要进行拦截，判断是否用户已经登录。\n如果在必须要登录的页面，用户没有登陆，则拦截后必须要进行登陆操作。\n\n如何实现线程隔离？我们可以使用threadlocal来做到线程隔离，每个线程操作自己的一份数据。\n如果看过threadLocal的源码，你会发现在threadLocal中，无论是他的put方法和他的get方法， 都是先从获得当前用户的线程，然后从线程中取出线程的成员变量map，只要线程不一样，map就不一样，所以可以通过这种方式来做到线程隔离。\n\n实现登录拦截\n拦截器\n\npublic class LoginInterceptor implements HandlerInterceptor &#123;    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;        //1.获取session        HttpSession session = request.getSession();        //2.获取session中的用户        Object user = session.getAttribute(&quot;user&quot;);        //3.判断用户是否存在        if(user == null)&#123;              //4.不存在，拦截，返回401状态码              response.setStatus(401);              return false;        &#125;        //5.存在，保存用户信息到Threadlocal        UserHolder.saveUser((UserDTO)user);        //6.放行        return true;    &#125;&#125;\n\n\n使拦截器生效\n\n@Configurationpublic class MvcConfig implements WebMvcConfigurer &#123;    @Override    public void addInterceptors(InterceptorRegistry registry) &#123;        // 登录拦截器        registry.addInterceptor(new LoginInterceptor())                .excludePathPatterns(                        &quot;/shop/**&quot;,                        &quot;/voucher/**&quot;,                        &quot;/shop-type/**&quot;,                        &quot;/upload/**&quot;,                        &quot;/blog/hot&quot;,                        &quot;/user/code&quot;,                        &quot;/user/login&quot;                );  //这些路径是不需要拦截的，即不需要登陆即可访问    &#125;&#125;\n\n\nUserHolder\n\npublic class UserHolder &#123;    private static final ThreadLocal&lt;UserDTO&gt; tl = new ThreadLocal&lt;&gt;();    public static void saveUser(UserDTO user)&#123;        tl.set(user);    &#125;    public static UserDTO getUser()&#123;        return tl.get();    &#125;    public static void removeUser()&#123;        tl.remove();    &#125;&#125;\n\n基于 Session 实现短信登录存在的问题在集群模式下，基于 Session 实现的短信登录就会出现问题。假设用户第一次登录的时候负载均衡到了服务器A，在服务器A进行了登录，登录信息也保存在了服务器A。当用户第二次访问的时候，负载均衡到了服务器B，此时服务器B的session中是没有用户的登录信息的，所以用户必须进行重新登录。这样会给用户体验带来很大影响。\n早期解决方案：session拷贝，就是说虽然每个tomcat上都有不同的session，但是每当任意一台服务器的session修改时，都会同步给其他的Tomcat服务器的session，这样的话，就可以实现session的共享了。\n但这种方案会有问题：（1）每台服务器中都有完整的一份session数据，服务器压力过大。（2）session拷贝数据时，可能会出现延迟。\n所以咱们后来采用的方案都是基于Redis来完成，我们把session换成redis，redis数据本身就是共享的，就可以避免session共享的问题了。\n\n基于 Redis 实现短信登录Redis 数据结构选择对于存储用户信息，可以选择 String 或者 Hash 类型的数据结构\n选择 String 类型的数据结构：\n\n优点：以 JSON字符串来保存，比较直观\n缺点：较 Hash类型来说比较占用内存，因为 JSON字符串中有一些符号会占用额外内存\n\n选择 Hash 类型的数据结构：\n\n优点：可以对单个字段进行 CRUD，占用内存少\n\n\n为了方便的话可以选择String\n\nKey 的设计及登录整体流程\n在基于Session实现的登录中，向session中存放用户信息\nsession.setAttribute(&quot;user&quot;, BeanUtils.copyProperties(user,UserDTO.class));\n\n使用的kay为 “code”，但使用Redis实现的时候，肯定不能使用 “code” 为 key，因为 Redis 是多个服务器 tomcat 共享的。\n\n所以key需要有唯一性，我们可以在后端生成一个随机 token 字符串作为 key，value为用户信息，保存到redis中。并把 token 返回给前端，浏览器可以保存到浏览器本地存储，下一次请求的时候，可以携带 token （请求头中 Authorization 字段）。拦截器中可以取出 token ，查询 Redis查出用户信息，如果存在用户信息，则保存到 ThreadLocal并放行，如果没有用户信息则拦截。\n总体流程：\n\n发送短信验证码功能改动就是将验证码保存到 Redis，但是要注意 key的设计，并设置key的过期时间\n\nkey : login:code:13333333333\nvalue: 验证码\n\n@Overridepublic Result sendCode(String phone, HttpSession session) &#123;    // 1.校验手机号    if (RegexUtils.isPhoneInvalid(phone)) &#123;        // 2.手机号非法，返回错误信息        return Result.fail(&quot;手机号格式错误！&quot;);    &#125;    // 3.手机号合法，生成验证码    // 使用工具类生成6位验证码    String code = RandomUtil.randomNumbers(6);    // 4.保存验证码到Redis    stringRedisTemplate.opsForValue().set(LOGIN_CODE_KEY + phone,            code, Duration.ofMinutes(LOGIN_CODE_TTL));    // 5.发送验证码    // TODO 暂时不做 要调用第三方平台 这里只是记录一下日志    log.debug(&quot;发送短信验证码成功: &#123;&#125;&quot;, code);    return Result.ok();&#125;\n\n登录\nkey: login:token:irhioh1234u91\nvalue: hash类型的用户信息\n\n@Overridepublic Result login(LoginFormDTO loginForm, HttpSession session) &#123;    String phone = loginForm.getPhone();    String code = loginForm.getCode();    // 1.校验手机号    if (RegexUtils.isPhoneInvalid(phone)) &#123;        return Result.fail(&quot;手机号格式错误！&quot;);    &#125;    // 2.从Redis获取验证码，校验验证码    String cacheCode = stringRedisTemplate.opsForValue().get(LOGIN_CODE_KEY + phone);    if (cacheCode == null || !cacheCode.equals(code)) &#123;        // 3.验证码不存在或验证码不一致        return Result.fail(&quot;验证码输入错误！&quot;);    &#125;    // 4.输入正确，查询用户    User user = query().eq(&quot;phone&quot;, phone).one();    // 5.判断用户是否存在    if (user == null) &#123;        // 6.用户不存在，则注册：新建用户保存到数据库        user = createUserWithPhone(phone);        save(user);    &#125;    // 7.保存用户信息到session/Redis中    /*        注意，保存到session/Redis的用户信息，不要是全部用户信息，        既浪费内存又涉及用户隐私，存的时候保存UserDTO对象，        里面只有id、name、icon三个字段     */    // 随机生成token，作为登录令牌    String token = UUID.randomUUID().toString(true);    // 将User对象转换为Redis的Hash进行存储，key为token    UserDTO userDTO = BeanUtil.copyProperties(user, UserDTO.class);    // 将其转换UserDTO转换为Map，存到Redis，这里后面的目的是将UserDTO中的Long类型的id值转换为String类型    Map&lt;String, Object&gt; userMap = BeanUtil.beanToMap(userDTO, new HashMap&lt;&gt;(),            CopyOptions.create().setIgnoreNullValue(true).setFieldValueEditor((fieldName, fieldValue) -&gt; fieldValue.toString()));    stringRedisTemplate.opsForHash().putAll(LOGIN_USER_KEY + token, userMap);    // 设置有效期    stringRedisTemplate.expire(LOGIN_USER_KEY + token, Duration.ofMinutes(LOGIN_USER_TTL));    // 返回token    return Result.ok(token);&#125;\n\n登录拦截public class LoginInterceptor implements HandlerInterceptor &#123;        private StringRedisTemplate stringRedisTemplate;    public RefreshTokenInterceptor(StringRedisTemplate stringRedisTemplate) &#123;        this.stringRedisTemplate = stringRedisTemplate;    &#125;    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;        // 1.获取请求头中的token（前端是将token存放在请求头的authorization字段）        String token = request.getHeader(&quot;authorization&quot;);        if (StrUtil.isBlank(token)) &#123;            return false;        &#125;        // 2.获取Redis中的用户，以token为key        Map&lt;Object, Object&gt; userMap = stringRedisTemplate.opsForHash().entries(LOGIN_USER_KEY + token);        // 3.判断用户是否存在        if (userMap.isEmpty()) &#123;            return false;        &#125;        // 4.将Hash数据转换为UserDTO对象        UserDTO userDTO = BeanUtil.fillBeanWithMap(userMap, new UserDTO(), false);        // 5.存在，存放到ThreadLocal中        UserHolder.saveUser(userDTO);        // 6.刷新Redis中token的过期时间        stringRedisTemplate.expire(LOGIN_USER_KEY + token, Duration.ofMinutes(LOGIN_USER_TTL));        // 放行        return true;    &#125;&#125;\n\n登录拦截存在的问题及优化存在的问题目前的登录拦截中，会对 Redis 中的token进行过期时间的刷新，避免用户频繁重新登录，这是没问题的。\n但目前存在的问题是，拦截器是只拦截了部分请求（需要登录的才会拦截）。如果用户登录之后，一直在浏览不需要登录的页面（比如首页、商铺等等），那么用户的请求都没有被拦截过，也不会进行 token 过期时间的刷新，当 token 过期后，用户就需要重新登陆。\n\n会出现用户一直在访问应用（虽然是不需要登录的页面），过一会突然需要重新登录\n\n\n优化优化方案为，新增加一个拦截器。\n第一个拦截所有请求，将获取token、查询redis、保存到ThreadLocal、刷新token过期时间放到第一个拦截器中。\n第二个拦截器拦截需要登录的请求，试图从ThreadLocal中取出登录用户，判断是否存在用户\n\n\nRefreshTokenIntercepter\npublic class RefreshTokenInterceptor implements HandlerInterceptor &#123;    private StringRedisTemplate stringRedisTemplate;    public RefreshTokenInterceptor(StringRedisTemplate stringRedisTemplate) &#123;        this.stringRedisTemplate = stringRedisTemplate;    &#125;    /**     * 拦截一切请求，检验token，进行token过期时间的刷新.     * 否则如果只是在需要登录的页面才刷新token的话，     * 如果用户登录之后，一直浏览不需要登录的页面，过一会也需要重新登陆，体验很差     */    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;        // 1.获取请求头中的token（前端是将token存放在请求头的authorization字段）        String token = request.getHeader(&quot;authorization&quot;);        if (StrUtil.isBlank(token)) &#123;            /*                这里就算token为空，也要放行，因为用户访问的可能是不需要登陆的页面                如果访问的是需要登录的页面，则会在下一个拦截器被拦截             */            //这个拦截器只是为了刷新token过期时间，如果必须登录页面会在LoginInterceptor拦截            return true;        &#125;        // 2.获取Redis中的用户，以token为key        Map&lt;Object, Object&gt; userMap = stringRedisTemplate.opsForHash().entries(LOGIN_USER_KEY + token);        // 3.判断用户是否存在        if (userMap.isEmpty()) &#123;            // 放行，理由同上            return true;        &#125;        // 4.将Hash数据转换为UserDTO对象        UserDTO userDTO = BeanUtil.fillBeanWithMap(userMap, new UserDTO(), false);        // 5.存在，存放到ThreadLocal中        UserHolder.saveUser(userDTO);        // 6.刷新Redis中token的过期时间        stringRedisTemplate.expire(LOGIN_USER_KEY + token, Duration.ofMinutes(LOGIN_USER_TTL));        // 放行        return true;    &#125;    @Override    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;        // 移除用户，避免内存泄露        UserHolder.removeUser();    &#125;&#125;\n\nLoginIntercepter\npublic class LoginInterceptor implements HandlerInterceptor &#123;    /**     * 需要用户信息的页面，进行拦截，检查用户是否已登陆。     * 从ThreadLocal中取，如果用户存在，则放行     */    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;        // 判断是否需要拦截        if (UserHolder.getUser() == null) &#123;            response.setStatus(401);            return false;        &#125;        // 有用户信息，放行        return true;    &#125;&#125;\n\nMvcConfig\n@Configurationpublic class MvcConfig implements WebMvcConfigurer &#123;    @Autowired    private StringRedisTemplate stringRedisTemplate;    @Override    public void addInterceptors(InterceptorRegistry registry) &#123;        //登录拦截器，需要校验用户信息时拦截        //下面的路径是排除的，不需要拦截的。        registry.addInterceptor(new LoginInterceptor())                .excludePathPatterns(                        &quot;/user/code&quot;,                        &quot;/user/login&quot;,                        &quot;/blog/hot&quot;,                        &quot;/shop/**&quot;,                        &quot;/shop-type/**&quot;,                        &quot;/upload/**&quot;,                        &quot;/voucher/**&quot;                ).order(1);        //拦截所有请求的拦截器，进行Token过期时间刷新        //注意刷新token的拦截器优先级更高，通过order指定优先级        registry.addInterceptor(new RefreshTokenInterceptor(stringRedisTemplate)).order(0);    &#125;&#125;\n\n查询缓存添加缓存\n查询的时候，先查询Redis，如果缓存数据存在，直接返回。\n如果缓存数据不在，查询数据库，再将查询到的数据存入 Redis\n\n\n代码实现：\n\n实现缓存数据库双写一致性\n选择旁路缓存模式的缓存更新策略，且是更新数据库并删除缓存。\n读策略：先查缓存，不存在再查数据库，并写入缓存。\n写策略：先更新数据库，在删除缓存。\n\n查询在上述代码实现中 （queryById方法），在写入 Redis的时候，给Key加一个过期时间即可。\n更新\n先更新数据库，再删除缓存。并且需要保证原子性，加上 @Transactional 注解\n\n\n缓存穿透及解决\n缓存穿透：缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。\n常见的解决方案有两种：\n\n缓存空对象 \n\n\n优点：实现简单，维护方便\n缺点： 额外的内存消耗、可能造成短期的不一致\n\n\n布隆过滤 \n\n\n优点：内存占用较少，没有多余key\n缺点： 实现复杂、存在误判可能\n\n\n\n\n缓存空对象思路分析：当我们客户端访问不存在的数据时，先请求redis，但是此时redis中没有数据，此时会访问到数据库，但是数据库中也没有数据，这个数据穿透了缓存，直击数据库，我们都知道数据库能够承载的并发不如redis这么高，如果大量的请求同时过来访问这种不存在的数据，这些请求就都会访问到数据库，简单的解决方案就是哪怕这个数据在数据库中也不存在，我们也把这个数据（空）存入到redis中去，这样，下次用户过来访问这个不存在的数据，那么在redis中也能找到这个数据就不会进入到缓存了\n布隆过滤：布隆过滤器其实采用的是哈希思想来解决这个问题，通过一个庞大的二进制数组，走哈希思想去判断当前这个要查询的这个数据是否存在，如果布隆过滤器判断存在，则放行，这个请求会去访问redis，哪怕此时redis中的数据过期了，但是数据库中一定存在这个数据，在数据库中查询出来这个数据后，再将其放入到redis中。\n\n这里使用第一种方法解决\n代码实现private Result queryShopForCachePenetration(Long id) &#123;    String key = CACHE_SHOP_KEY + id;    // 从Redis查询商铺缓存    String cacheShop = stringRedisTemplate.opsForValue().get(key);    // 如果命中缓存    if (cacheShop != null) &#123;        // cacheShop为空字符串值，返回，解决缓存穿透        if (&quot;&quot;.equals(cacheShop)) return null;        //反序列化        Shop shop = JSONUtil.toBean(cacheShop, Shop.class);        return Result.ok(shop);    &#125;    // 如果未命中缓存，在数据库中查询    Shop shop = baseMapper.selectById(id);    // 判断商铺是否存在    if (shop == null) &#123;        /*            当缓存和数据库都查不到时，缓存空值并返回            解决缓存穿透         */        stringRedisTemplate.opsForValue().set(                key, &quot;&quot;, Duration.ofMinutes(CACHE_NULL_TTL));        Result.fail(&quot;店铺不存在！&quot;);    &#125;    // 商铺存在，序列化为json串，写入缓存    String shopJson = JSONUtil.toJsonStr(shop);    stringRedisTemplate.opsForValue().set(            key, shopJson, Duration.ofMinutes(CACHE_SHOP_TTL));    return Result.ok(shop);&#125;\n\n缓存雪崩及解决思路\n缓存雪崩是指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。\n\n解决方案：\n\n给不同的Key的TTL添加随机值\n利用Redis集群提高服务的可用性\n给缓存业务添加降级限流策略\n给业务添加多级缓存\n\n缓存击穿及解决\n缓存击穿问题也叫热点Key问题，就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。\n假设高并发访问某个失效的key，线程1查询缓存，发现不存在，需要查询数据库，然后进行缓存重建。此时还未完成的时候，其余线程也同时访问这个key（此时线程1的缓存重建还没有完成），则其余线程也都会查询数据库，导致大量请求到达数据库导致数据库压力过大。\n\n\n解决思路\n使用互斥锁解决缓存击穿\n线程1查询缓存未命中后，进行缓存重建之前，需要先获取互斥锁，只有获取互斥锁成功的线程才能进行缓存重建。没有获取到互斥锁的线程就需要休眠等待再进行重试。\n\n\n逻辑过期方案解决缓存击穿\n我们之所以会出现这个缓存击穿问题，主要原因是在于我们对key设置了过期时间，假设我们不设置过期时间，其实就不会有缓存击穿的问题，但是不设置过期时间，这样数据不就一直占用我们内存了吗，我们可以采用逻辑过期方案。\n我们把过期时间设置在 redis 的 value 中，注意：这个过期时间并不会直接作用于redis，而是我们后续通过逻辑去处理。假设线程1去查询缓存，然后从value中判断出来当前的数据已经过期了，此时线程1去获得互斥锁，那么其他线程会进行阻塞，获得了锁的线程他会开启一个新线程去进行缓存重建，直到新开的线程完成这个逻辑后，才释放锁。 而线程1直接进行返回已经逻辑过期的数据，假设现在线程3过来访问，由于线程线程2持有着锁，所以线程3无法获得锁，线程3也直接返回数据，只有等到新开的线程2把重建数据构建完后，其他线程才能走返回正确的数据。\n这种方案巧妙在于，异步的构建缓存，缺点在于在构建完缓存之前，返回的都是脏数据。\n\n\n\n方案对比：\n互斥锁方案：由于保证了互斥性，所以数据一致，且实现简单，因为仅仅只需要加一把锁而已，也没其他的事情需要操心，所以没有额外的内存消耗，缺点在于有锁就有死锁问题的发生，且只能串行执行性能肯定受到影响\n逻辑过期方案： 线程读取过程中不需要等待，性能好，有一个额外的线程持有锁去进行重构数据，但是在重构数据完成前，其他的线程只能返回之前的数据，且实现起来麻烦\n使用互斥锁解决缓存击穿\n@Overridepublic Result queryShopById(Long id) &#123;\tShop shop = queryShopForCacheBreakdown(id);    if (shop == null) return Result.fail(&quot;店铺不存在！&quot;);    return Result.ok(shop);&#125;private Shop queryShopForCacheBreakdown(Long id) &#123;    String key = CACHE_SHOP_KEY + id;    // 从Redis查询商铺缓存    String cacheShop = stringRedisTemplate.opsForValue().get(key);    // 如果命中缓存    if (cacheShop != null) &#123;        // cacheShop为空字符串值，返回，解决缓存穿透        if (&quot;&quot;.equals(cacheShop)) return null;        //反序列化        return JSONUtil.toBean(cacheShop, Shop.class);    &#125;    // 如果未命中缓存，查数据库进行缓存重建    // 获取互斥锁    String lockKey = LOCK_SHOP_KEY + id;    Shop shop = null;    try &#123;        boolean isLocked = lock(lockKey);        // 获取锁失败，休眠并重试        if (!isLocked) &#123;            Thread.sleep(50); //休眠            return queryShopForCacheBreakdown(id); //重试        &#125;        // 获取锁成功        // 再次检查一次缓存是否存在 （Double Check)        cacheShop = stringRedisTemplate.opsForValue().get(key);        // 如果命中缓存        if (cacheShop != null) &#123;            // cacheShop为空字符串值，返回，解决缓存穿透            if (&quot;&quot;.equals(cacheShop)) return null;            //反序列化            return JSONUtil.toBean(cacheShop, Shop.class);        &#125;        // 在数据库中查询        shop = baseMapper.selectById(id);        // 判断商铺是否存在        if (shop == null) &#123;            /*                当缓存和数据库都查不到时，缓存空值并返回                解决缓存穿透             */            stringRedisTemplate.opsForValue().set(                    key, &quot;&quot;, Duration.ofMinutes(CACHE_NULL_TTL));            return null;        &#125;        // 商铺存在，序列化为json串，写入缓存        String shopJson = JSONUtil.toJsonStr(shop);        stringRedisTemplate.opsForValue().set(                key, shopJson, Duration.ofMinutes(CACHE_SHOP_TTL));    &#125; catch (InterruptedException e) &#123;        throw new RuntimeException(e);    &#125; finally &#123;        // 释放互斥锁        unlock(lockKey);    &#125;    return shop;&#125;/** * 获取互斥锁 * @param key key * @return 获取锁是否成功 */private boolean lock(String key) &#123;    Boolean flag = stringRedisTemplate.opsForValue()            .setIfAbsent(key, &quot;1&quot;, Duration.ofSeconds(LOCK_SHOP_TTL));    //不要直接 return flag, 可能拆箱会发生空指针异常    return BooleanUtil.isTrue(flag);&#125;/** * 释放互斥锁 * @param key key */private void unlock(String key) &#123;    stringRedisTemplate.delete(key);&#125;\n\n利用逻辑过期解决缓存击穿当用户开始查询redis时，判断是否命中，如果没有命中则直接返回空数据，不查询数据库，而一旦命中后，将value取出，判断value中的过期时间是否满足，如果没有过期，则直接返回redis中的数据，如果过期，则在开启独立线程后直接返回之前的数据，独立线程去重构数据，重构完成后释放互斥锁。\n\nprivate Shop queryShopForCacheBreakdownWithLogicalExpire(Long id) &#123;    String key = CACHE_SHOP_KEY + id;    // 从Redis查询商铺缓存    String cacheShop = stringRedisTemplate.opsForValue().get(key);    /*        如果命中未缓存，直接返回null.        因为使用逻辑过期方式解决的话，是肯定能查询到缓存的（第一次会预热，而且没有过期时间）        如果未命中缓存，说明不存在店铺     */    if (cacheShop == null) &#123;        return null;    &#125;    // 命中缓存，反序列化Json，检查缓存中的逻辑过期时间    RedisData redisData = JSONUtil.toBean(cacheShop, RedisData.class);    Shop shop = JSONUtil.toBean((JSONObject)redisData.getData(), Shop.class); //取出店铺信息    LocalDateTime expireTime = redisData.getExpireTime(); //取出过期时间    // 未过期，直接返回店铺信息    if (expireTime.isAfter(LocalDateTime.now())) &#123;        return shop;    &#125;    // 已过期，进行缓存重建    // 获取互斥锁    String lockKey = LOCK_SHOP_KEY + id;    boolean isLocked = lock(lockKey);    // 获取锁成功，开启独立线程实现缓存重建    if (isLocked) &#123;        CACHE_REBUILD_EXECUTOR.submit(() -&gt; &#123;            try &#123;                //重建缓存                saveShop2Redis(id, 20L);            &#125; catch (Exception e) &#123;                throw new RuntimeException(e);            &#125; finally &#123;                //释放锁                unlock(lockKey);            &#125;        &#125;);    &#125;    // 返回商铺信息（过期的商铺信息）    return shop;&#125;/** * 此方法目的：缓存重建 / 数据预热，加上逻辑过期时间存入Redis。 * * 将shop封装（封装为RedisData类，里面由过期时间字段），存入redis。 * @param id shop id * @param expireSeconds 多少秒逻辑过期 */public void saveShop2Redis(Long id, Long expireSeconds) &#123;    // 查出shop    Shop shop = baseMapper.selectById(id);    // 封装shop到redisData    RedisData redisData = new RedisData();    redisData.setData(shop);    redisData.setExpireTime(LocalDateTime.now().plusSeconds(expireSeconds));    // 写入Redis    stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY + id, JSONUtil.toJsonStr(redisData));&#125;\n\n封装工具类@Slf4j@Componentpublic class CacheClient &#123;    @Autowired    private StringRedisTemplate stringRedisTemplate;    // 缓存重建的线程池    private static final ThreadPoolExecutor CACHE_REBUILD_EXECUTOR = new ThreadPoolExecutor(            CORE_POOL_SIZE,            MAX_POOL_SIZE,            KEEP_ALIVE_TIME,            TimeUnit.SECONDS,            new ArrayBlockingQueue&lt;&gt;(QUEUE_CAPACITY),            new ThreadPoolExecutor.CallerRunsPolicy()    );    /**     * 将任意Java对象序列化为json并存储在string类型的key中，并且可以设置TTL过期时间     * @param key 存入Redis的Key     * @param value 任意对象     * @param time 过期时间     * @param unit 时间单位     */    public void set(String key, Object value, Long time, TimeUnit unit) &#123;        stringRedisTemplate.opsForValue()                .set(key, JSONUtil.toJsonStr(value), time, unit);    &#125;    /**     * 将任意Java对象序列化为json并存储在string类型的key中，     * 并且可以设置逻辑过期时间，用于处理缓存击穿问题     * @param key 存入Redis的key     * @param value 任意对象     * @param time 过期时间     * @param unit 时间单位     */    public void setWithLogicExpire(String key, Object value, Long time, TimeUnit unit) &#123;        // 封装为RedisData，有逻辑过期字段        RedisData redisData = new RedisData();        redisData.setData(value);        redisData.setExpireTime(LocalDateTime.now().plusSeconds(unit.toSeconds(time)));        // 写入Redis        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData));    &#125;    /**     * 根据指定的key查询缓存，并反序列化为指定类型，利用缓存空值的方式解决缓存穿透问题     * @param keyPrefix Redis的key的前缀     * @param id 需要查询的对象的id     * @param type 需要查询的对象的Class类     * @param dbFallback 函数式编程，传入一段逻辑（因为查数据库时，不知道需要怎么查数据库，所以需要传入逻辑）     * @param time 如果缓存中没有，查询数据库，存入缓存时的过期时间     * @param unit 过期时间的单位     * @return 返回需要查询的对象，使用泛型     * @param &lt;R&gt; 需要查询的对象类型     * @param &lt;ID&gt; id的类型，不确定。     */    public &lt;R, ID&gt; R queryForCachePenetration(String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit) &#123;        String key = keyPrefix + id;        // 从Redis中查询缓存        String json = stringRedisTemplate.opsForValue().get(key);        // 如果命中缓存        if (json != null) &#123;            // json为空字符串值，返回，解决缓存穿透            if (&quot;&quot;.equals(json)) return null;            //反序列化            return JSONUtil.toBean(json, type);        &#125;        // 如果未命中缓存，在数据库中查询        R r = dbFallback.apply(id);        // 判断数据库查询出的对象是否存在        if (r == null) &#123;            /*                当缓存和数据库都查不到时，缓存空值并返回                解决缓存穿透             */            stringRedisTemplate.opsForValue().set(                    key, &quot;&quot;, Duration.ofMinutes(CACHE_NULL_TTL));            return null;        &#125;        // 存在，序列化为json串，写入缓存        this.set(key, r, time, unit);        return r;    &#125;    /**     * 根据指定的key查询缓存，并反序列化为指定类型，需要利用逻辑过期解决缓存击穿问题     * @param keyPrefix Redis的Key前缀     * @param id 需要查询的id     * @param type 需要查询的对象的Class     * @param dbFallback 函数式编程，传入一段逻辑（因为查数据库时，不知道需要怎么查数据库，所以需要传入逻辑）     * @param time 逻辑过期时间     * @param unit 过期时间单位     * @return 需要查询的对象     * @param &lt;R&gt; 需要查询的对象类型     * @param &lt;ID&gt; 需要查询的对象的id类型     */    public &lt;R, ID&gt; R queryForCacheBreakdownWithLogicalExpire(String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit) &#123;        String key = keyPrefix + id;        // 从Redis查询缓存        String json = stringRedisTemplate.opsForValue().get(key);        /*            如果命中未缓存，直接返回null.            因为使用逻辑过期方式解决的话，是肯定能查询到缓存的（第一次会预热，而且没有过期时间）            如果未命中缓存，说明不存在         */        if (json == null) &#123;            return null;        &#125;        // 命中缓存，反序列化Json，检查缓存中的逻辑过期时间        RedisData redisData = JSONUtil.toBean(json, RedisData.class);        R r = JSONUtil.toBean((JSONObject)redisData.getData(), type); //取出对象信息        LocalDateTime expireTime = redisData.getExpireTime(); //取出过期时间        // 未过期，直接返回        if (expireTime.isAfter(LocalDateTime.now())) &#123;            return r;        &#125;        // 已过期，进行缓存重建        // 获取互斥锁        String lockKey = LOCK_SHOP_KEY + id;        boolean isLocked = lock(lockKey);        // 获取锁成功，开启独立线程实现缓存重建        if (isLocked) &#123;            CACHE_REBUILD_EXECUTOR.submit(() -&gt; &#123;                try &#123;                    //重建缓存，先查数据库，再写入Redis (封装为RedisData，携带逻辑过期时间）                    R newR = dbFallback.apply(id);                    this.setWithLogicExpire(key, newR, time, unit);                &#125; catch (Exception e) &#123;                    throw new RuntimeException(e);                &#125; finally &#123;                    //释放锁                    unlock(lockKey);                &#125;            &#125;);        &#125;        // 返回对象信息（过期的对象信息）        return r;    &#125;    /**     * 获取互斥锁     * @param key key     * @return 获取锁是否成功     */    private boolean lock(String key) &#123;        Boolean flag = stringRedisTemplate.opsForValue()                .setIfAbsent(key, &quot;1&quot;, Duration.ofSeconds(LOCK_SHOP_TTL));        //不要直接 return flag, 可能拆箱会发生空指针异常        return BooleanUtil.isTrue(flag);    &#125;    /**     * 释放互斥锁     * @param key key     */    private void unlock(String key) &#123;        stringRedisTemplate.delete(key);    &#125;&#125;\n\n优惠券秒杀全局唯一ID下订单的时候，会为每个订单分配一个订单ID，如果仅仅依靠数据库自增ID会有两个问题：\n\nID的规律性太明显，可以通过订单ID看出商城的销售额\n订单规模一般很大，所以可能需要进行数据库分表，将订单表分为多张不同的表，但逻辑上是同一张表，所以订单ID一定不能重复。\n\n我们可以使用Redis来实现全局唯一ID生成器。\n\n全局唯一ID的设计为了增加ID的安全性，我们可以不直接使用Redis自增的数值，而是拼接一些其它信息：\n\nID的组成部分：\n\n符号位：1bit，永远为0\n时间戳：31bit，以秒为单位，可以使用69年\n序列号：32bit，秒内的计数器，支持每秒产生2^32个不同ID\n\nRedis 实现全局唯一ID@Componentpublic class RedisIdWorker &#123;    // 初始时间戳，2022年1月1日0点0分0秒    private static final long BEGIN_TIMESTAMP = 1640995200L;    // 序列号的位数，32位    private static final int COUNT_BITS = 32;    @Autowired    private StringRedisTemplate stringRedisTemplate;    /**     * 使用Redis实现Id生成器，全局唯一ID     * @param keyPrefix 区分不同业务     * @return long型id     */    public long nextId(String keyPrefix) &#123;        /*            ID的组成：时间戳 + 序列号            8字节64位，第一位位符号位，为0            后面31bit的时间戳，和32bit的序列号         */        // 生成时间戳：获取当前时间，减去初始时间戳        LocalDateTime now = LocalDateTime.now();        long current = now.toEpochSecond(ZoneOffset.UTC);        long timestamp = current - BEGIN_TIMESTAMP; //时间戳        // 利用Redis的自增生成序列号count        // 在Redis中key为 icr:keyPrefix:2023:05:08:        String date = now.format(DateTimeFormatter.ofPattern(&quot;yyyy:MM:dd&quot;));        long count = stringRedisTemplate.opsForValue()                .increment(&quot;icr:&quot; + keyPrefix + &quot;:&quot; + date);        /*            拼接并返回（不是字符串的拼接，因为需要返回long型。            所以先将时间戳向左移32位，留出序列号的位置，然后或运算序列号         */        return timestamp &lt;&lt; COUNT_BITS | count;    &#125;&#125;\n\n秒杀下单秒杀下单应该思考的内容：\n下单时需要判断两点：\n\n秒杀是否开始或结束，如果尚未开始或已经结束则无法下单\n库存是否充足，不足则无法下单\n\n下单核心逻辑分析：\n当用户开始进行下单，我们应当去查询优惠卷信息，查询到优惠卷信息，判断是否满足秒杀条件\n比如时间是否充足，如果时间充足，则进一步判断库存是否足够，如果两者都满足，则扣减库存，创建订单，然后返回订单id，如果有一个条件不满足则直接结束。\n\n@Overridepublic Result seckillVoucher(Long voucherId) &#123;    // 1.查询优惠券    SeckillVoucher voucher = seckillVoucherService.getById(voucherId);    // 2.判断秒杀是否开始    if (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;        // 尚未开始        return Result.fail(&quot;秒杀尚未开始！&quot;);    &#125;    // 3.判断秒杀是否已经结束    if (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123;        // 尚未开始        return Result.fail(&quot;秒杀已经结束！&quot;);    &#125;    // 4.判断库存是否充足    if (voucher.getStock() &lt; 1) &#123;        // 库存不足        return Result.fail(&quot;库存不足！&quot;);    &#125;    //5，扣减库存    boolean success = seckillVoucherService.update()            .setSql(&quot;stock= stock -1&quot;)            .eq(&quot;voucher_id&quot;, voucherId).update();    if (!success) &#123;        //扣减库存        return Result.fail(&quot;库存不足！&quot;);    &#125;    //6.创建订单    VoucherOrder voucherOrder = new VoucherOrder();    // 6.1.订单id    long orderId = redisIdWorker.nextId(&quot;order&quot;);    voucherOrder.setId(orderId);    // 6.2.用户id    Long userId = UserHolder.getUser().getId();    voucherOrder.setUserId(userId);    // 6.3.代金券id    voucherOrder.setVoucherId(voucherId);    save(voucherOrder);    return Result.ok(orderId);&#125;\n\n乐观锁解决超卖问题方案一：\nVoucherOrderServiceImpl 在扣减库存时，改为：\nboolean success = seckillVoucherService.update()            .setSql(&quot;stock= stock -1&quot;) //set stock = stock -1            .eq(&quot;voucher_id&quot;, voucherId).eq(&quot;stock&quot;,voucher.getStock()).update(); //where id = ? and stock = ?\n\n以上逻辑的核心含义是：只要我扣减库存时的库存和之前我查询到的库存是一样的，就意味着没有人在中间修改过库存，那么此时就是安全的，但是以上这种方式通过测试发现会有很多失败的情况，失败的原因在于：在使用乐观锁过程中假设100个线程同时都拿到了100的库存，然后大家一起去进行扣减，但是100个人中只有1个人能扣减成功，其他的人在处理时，他们在扣减时，库存已经被修改过了，所以此时其他线程都会失败。\n方案二：\n之前的方式要修改前后都保持一致，但是这样我们分析过，成功的概率太低，所以我们的乐观锁需要变一下，改成stock大于0 即可\nboolean success = seckillVoucherService.update()            .setSql(&quot;stock= stock -1&quot;)            .eq(&quot;voucher_id&quot;, voucherId).update().gt(&quot;stock&quot;,0); //where id = ? and stock &gt; 0\n\n一人一单问题业务要求一个用户对同一个优惠券只能下一单。\n具体操作逻辑如下：比如时间是否充足，如果时间充足，则进一步判断库存是否足够，然后再根据优惠卷id和用户id查询是否已经下过这个订单，如果下过这个订单，则不再下单，否则进行下单。\n\npublic Result seckillVoucher(Long voucherId) &#123;    // 查询优惠券    SeckillVoucher voucher = seckillVoucherService.getById(voucherId);    // 判断秒杀时间 是否已开始，或是否已结束    if (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;        // 优惠券开始时间 晚于 当前时间，说明还没开始秒杀        return Result.fail(&quot;秒杀尚未开始！&quot;);    &#125;    if (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123;        // 优惠券结束时间 早于 当前时间，说明秒杀已结束        return Result.fail(&quot;秒杀活动已结束！&quot;);    &#125;    // 判断库存是否足够    if (voucher.getStock() &lt; 1) &#123;        //库存不足        return Result.fail(&quot;优惠券库存不足！&quot;);    &#125;    // 减库存、创建订单    Long userId = UserHolder.getUser().getId();    // 加锁实现，保证一人一单，锁当前用户    // 获取锁对象    SimpleRedisLock lock = new SimpleRedisLock(&quot;order:&quot; + userId, stringRedisTemplate);    // 获取锁    boolean isLocked = lock.tryLock(5);    if (!isLocked) &#123;        return Result.fail(&quot;不允许重复下单！&quot;);    &#125;    try &#123;        // 直接return createVoucherOrder(voucherId)的话，createVoucherOrder方法的事务是不生效的        // 获取代理对象（事务）        IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy();        return proxy.createVoucherOrder(voucherId);    &#125; finally &#123;        lock.unlock();    &#125;&#125;/** * 下单的部分逻辑：减库存，创建订单 * * @param voucherId 优惠券id * @return */@Transactional //有库存的扣减 和 订单的新增  两个数据库操作，加上事务保证原子性public Result createVoucherOrder(Long voucherId) &#123;    Long userId = UserHolder.getUser().getId();    // 实现一人一单，一个账户对于同一个优惠券，只能买一次，必须加锁实现    QueryWrapper&lt;VoucherOrder&gt; wrapper = new QueryWrapper&lt;&gt;();    wrapper.eq(&quot;user_id&quot;, userId)            .eq(&quot;voucher_id&quot;, voucherId);    int count = baseMapper.selectCount(wrapper);    if (count != 0) &#123;        return Result.fail(&quot;优惠券只能购买一次！&quot;);    &#125;    // 扣减库存    // 解决超卖问题，乐观锁CAS    // 减库存前，判断stock是否为之前查到的stock。where id = ? and stock = 原来查到的    // 优化：where id = ? and stock &gt; 0    boolean success = seckillVoucherService            .update()            .setSql(&quot;stock = stock - 1&quot;)            .eq(&quot;voucher_id&quot;, voucherId)            .gt(&quot;stock&quot;, 0) // where id = ? and stock &gt; 0            .update();    if (!success) return Result.fail(&quot;优惠券库存不足！&quot;);    // 创建订单    VoucherOrder order = new VoucherOrder();    // 订单id    long orderId = redisIdWorker.nextId(&quot;order&quot;); //全局唯一id    order.setId(orderId);    // 用户id    order.setUserId(userId);    // 代金券id    order.setVoucherId(voucherId);    // 保存订单到数据库    baseMapper.insert(order);    return Result.ok(orderId);&#125;\n\n集群环境下出现问题由于上面实现一人一单的过程中，进行加锁。但在集群环境下，这种锁会失效。这种锁只保证同一个JVM里不同的线程只有一个线程能获取到锁，但肯定不能实现不同的JVM只有一个线程获取到锁。\n\n所以需要使用分布式锁。\n","categories":["项目"],"tags":["Redis","分布式锁","缓存","消息队列"]},{"title":"乐观锁和悲观锁","url":"/2023/05/29/%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81/","content":"什么是悲观锁？悲观锁总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。也就是说，共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程。\n像 Java 中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。\npublic void performSynchronisedTask() &#123;    synchronized (this) &#123;        // 需要同步的操作    &#125;&#125;private Lock lock = new ReentrantLock();lock.lock();try &#123;   // 需要同步的操作&#125; finally &#123;    lock.unlock();&#125;\n\n高并发的场景下，激烈的锁竞争会造成线程阻塞，大量阻塞线程会导致系统的上下文切换，增加系统的性能开销。并且，悲观锁还可能会存在死锁问题，影响代码的正常运行。\n什么是乐观锁？乐观锁总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源（也就是数据）是否被其它线程修改了（具体方法可以使用版本号机制或 CAS 算法）。\n在 Java 中java.util.concurrent.atomic包下面的原子变量类（比如AtomicInteger、LongAdder）就是使用了乐观锁的一种实现方式 CAS 实现的。\n\n// LongAdder 在高并发场景下会比 AtomicInteger 和 AtomicLong 的性能更好// 代价就是会消耗更多的内存空间（空间换时间）LongAdder sum = new LongAdder();sum.increment();\n\n高并发的场景下，乐观锁相比悲观锁来说，不存在锁竞争造成线程阻塞，也不会有死锁的问题，在性能上往往会更胜一筹。但是，如果冲突频繁发生（写占比非常多的情况），会频繁失败和重试，这样同样会非常影响性能，导致 CPU 飙升。\n不过，大量失败重试的问题也是可以解决的，像我们前面提到的 LongAdder以空间换时间的方式就解决了这个问题。\n理论上来说：\n\n悲观锁通常多用于写比较多的情况下（多写场景，竞争激烈），这样可以避免频繁失败和重试影响性能，悲观锁的开销是固定的。不过，如果乐观锁解决了频繁失败和重试这个问题的话（比如LongAdder），也是可以考虑使用乐观锁的，要视实际情况而定。\n乐观锁通常多于写比较少的情况下（多读场景，竞争较少），这样可以避免频繁加锁影响性能。不过，乐观锁主要针对的对象是单个共享变量（参考java.util.concurrent.atomic包下面的原子变量类）。\n\n如何实现乐观锁？乐观锁一般会使用版本号机制或 CAS 算法实现，CAS 算法相对来说更多一些，这里需要格外注意。\n版本号机制一般是在数据表中加上一个数据版本号 version 字段，表示数据被修改的次数。当数据被修改时，version 值会加一。当线程 A 要更新数据值时，在读取数据的同时也会读取 version 值，在提交更新时，若刚才读取到的 version 值为当前数据库中的 version 值相等时才更新，否则重试更新操作，直到更新成功。\n举一个简单的例子：假设数据库中帐户信息表中有一个 version 字段，当前值为 1 ；而当前帐户余额字段（ balance ）为 $100 。\n\n操作员 A 此时将其读出（ version&#x3D;1 ），并从其帐户余额中扣除 $50（ $100-$50 ）。\n在操作员 A 操作的过程中，操作员 B 也读入此用户信息（ version&#x3D;1 ），并从其帐户余额中扣除 $20 （ $100-$20 ）。\n操作员 A 完成了修改工作，将数据版本号（ version&#x3D;1 ），连同帐户扣除后余额（ balance&#x3D;$50 ），提交至数据库更新，此时由于提交数据版本等于数据库记录当前版本，数据被更新，数据库记录 version 更新为 2 。\n操作员 B 完成了操作，也将版本号（ version&#x3D;1 ）试图向数据库提交数据（ balance&#x3D;$80 ），但此时比对数据库记录版本时发现，操作员 B 提交的数据版本号为 1 ，数据库记录当前版本也为 2 ，不满足 “ 提交版本必须等于当前版本才能执行更新 “ 的乐观锁策略，因此，操作员 B 的提交被驳回。\n\n这样就避免了操作员 B 用基于 version&#x3D;1 的旧数据修改的结果覆盖操作员 A 的操作结果的可能。\nCAS 算法CAS 的全称是 Compare And Swap（比较与交换） ，用于实现乐观锁，被广泛应用于各大框架中。CAS 的思想很简单，就是用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。\nCAS 是一个原子操作，底层依赖于一条 CPU 的原子指令。\n\n原子操作 即最小不可拆分的操作，也就是说操作一旦开始，就不能被打断，直到操作完成。\n\nCAS 涉及到三个操作数：\n\nV：要更新的变量值(Var)\nE：预期值(Expected)\nN：拟写入的新值(New)\n\n当且仅当 V 的值等于 E 时，CAS 通过原子方式用新值 N 来更新 V 的值。如果不等，说明已经有其它线程更新了 V，则当前线程放弃更新。\n举一个简单的例子：线程 A 要修改变量 i 的值为 6，i 原值为 1（V &#x3D; 1，E&#x3D;1，N&#x3D;6，假设不存在 ABA 问题）。\n\ni 与 1 进行比较，如果相等， 则说明没被其他线程修改，可以被设置为 6 。\ni 与 1 进行比较，如果不相等，则说明被其他线程修改，当前线程放弃更新，CAS 操作失败。\n\n当多个线程同时使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。\nJava 语言并没有直接实现 CAS，CAS 相关的实现是通过 C++ 内联汇编的形式实现的（JNI 调用）。因此， CAS 的具体实现和操作系统以及 CPU 都有关系。\nsun.misc包下的Unsafe类提供了compareAndSwapObject、compareAndSwapInt、compareAndSwapLong方法来实现的对Object、int、long类型的 CAS 操作\n/**\t*  CAS  * @param o         包含要修改field的对象  * @param offset    对象中某field的偏移量  * @param expected  期望值  * @param update    更新值  * @return          true | false  */public final native boolean compareAndSwapObject(Object o, long offset,  Object expected, Object update);public final native boolean compareAndSwapInt(Object o, long offset, int expected,int update);public final native boolean compareAndSwapLong(Object o, long offset, long expected, long update);\n\n乐观锁存在哪些问题？ABA 问题是乐观锁最常见的问题。\nABA 问题如果一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然是 A 值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回 A，那 CAS 操作就会误认为它从来没有被修改过。这个问题被称为 CAS 操作的 “ABA”问题。\nABA 问题的解决思路是在变量前面追加上版本号或者时间戳。JDK 1.5 以后的 AtomicStampedReference 类就是用来解决 ABA 问题的，其中的 compareAndSet() 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。\npublic boolean compareAndSet(V   expectedReference,                             V   newReference,                             int expectedStamp,                             int newStamp) &#123;    Pair&lt;V&gt; current = pair;    return        expectedReference == current.reference &amp;&amp;        expectedStamp == current.stamp &amp;&amp;        ((newReference == current.reference &amp;&amp;          newStamp == current.stamp) ||         casPair(current, Pair.of(newReference, newStamp)));&#125;\n\n循环时间长开销大CAS 经常会用到自旋操作来进行重试，也就是不成功就一直循环执行直到成功。如果长时间不成功，会给 CPU 带来非常大的执行开销。\n如果 JVM 能支持处理器提供的 pause 指令那么效率会有一定的提升，pause 指令有两个作用：\n\n可以延迟流水线执行指令，使 CPU 不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。\n可以避免在退出循环的时候因内存顺序冲而引起 CPU 流水线被清空，从而提高 CPU 的执行效率。\n\n只能保证一个共享变量的原子操作CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5 开始，提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用\n","categories":["Java"],"tags":["锁","并发"]},{"title":"如何实现分布式锁？","url":"/2023/05/27/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%EF%BC%9F/","content":"\n本文源自 https://javaguide.cn/ \n\n分布式锁介绍对于单机多线程来说，在 Java 中，我们通常使用 ReetrantLock 类、synchronized 关键字这类 JDK 自带的 本地锁 来控制一个 JVM 进程内的多个线程对本地共享资源的访问。\n下面是我对本地锁画的一张示意图。\n\n从图中可以看出，这些线程访问共享资源是互斥的，同一时刻只有一个线程可以获取到本地锁访问共享资源。\n分布式系统下，不同的服务&#x2F;客户端通常运行在独立的 JVM 进程上。如果多个 JVM 进程共享同一份资源的话，使用本地锁就没办法实现资源的互斥访问了。于是，分布式锁 就诞生了。\n举个例子：系统的订单服务一共部署了 3 份，都对外提供服务。用户下订单之前需要检查库存，为了防止超卖，这里需要加锁以实现对检查库存操作的同步访问。由于订单服务位于不同的 JVM 进程中，本地锁在这种情况下就没办法正常工作了。我们需要用到分布式锁，这样的话，即使多个线程不在同一个 JVM 进程中也能获取到同一把锁，进而实现共享资源的互斥访问。\n下面是我对分布式锁画的一张示意图。\n\n从图中可以看出，这些独立的进程中的线程访问共享资源是互斥的，同一时刻只有一个线程可以获取到分布式锁访问共享资源。\n一个最基本的分布式锁需要满足：\n\n互斥 ：任意一个时刻，锁只能被一个线程持有；\n高可用 ：锁服务是高可用的。并且，即使客户端的释放锁的代码逻辑出现问题，锁最终一定还是会被释放，不会影响其他线程对共享资源的访问。\n可重入：一个节点获取了锁之后，还可以再次获取锁。\n\n通常情况下，我们一般会选择基于 Redis 或者 ZooKeeper 实现分布式锁，Redis 用的要更多一点，我这里也以 Redis 为例介绍分布式锁的实现。\n基于 Redis 实现分布式锁如何基于 Redis 实现一个最简易的分布式锁？不论是本地锁还是分布式锁，核心都在于“互斥”。\n在 Redis 中， SETNX 命令是可以帮助我们实现互斥。SETNX 即 SET if Not eXists (对应 Java 中的 setIfAbsent 方法)，如果 key 不存在的话，才会设置 key 的值。如果 key 已经存在， SETNX 啥也不做。\n&gt; SETNX lockKey uniqueValue(integer) 1&gt; SETNX lockKey uniqueValue(integer) 0\n\n释放锁的话，直接通过 DEL 命令删除对应的 key 即可。\n&gt; DEL lockKey(integer) 1\n\n为了防止误删到其他的锁，这里我们建议使用 Lua 脚本通过 key 对应的 value（唯一值）来判断。\n选用 Lua 脚本是为了保证解锁操作的原子性。因为 Redis 在执行 Lua 脚本时，可以以原子性的方式执行，从而保证了锁释放操作的原子性。\n// 释放锁时，先比较锁对应的 value 值是否相等，避免锁的误释放if redis.call(&quot;get&quot;,KEYS[1]) == ARGV[1] then    return redis.call(&quot;del&quot;,KEYS[1])else    return 0end\n\n\n这是一种最简易的 Redis 分布式锁实现，实现方式比较简单，性能也很高效。不过，这种方式实现分布式锁存在一些问题。就比如应用程序遇到一些问题比如释放锁的逻辑突然挂掉，可能会导致锁无法被释放，进而造成共享资源无法再被其他线程&#x2F;进程访问。\n为什么要给锁设置一个过期时间？为了避免锁无法被释放，我们可以想到的一个解决办法就是： 给这个 key（也就是锁） 设置一个过期时间 。\n127.0.0.1:6379&gt; SET lockKey uniqueValue EX 3 NXOK\n\n\nlockKey ：加锁的锁名；\nuniqueValue ：能够唯一标示锁的随机字符串；\nNX ：只有当 lockKey 对应的 key 值不存在的时候才能 SET 成功；\nEX ：过期时间设置（秒为单位）EX 3 标示这个锁有一个 3 秒的自动过期时间。与 EX 对应的是 PX（毫秒为单位），这两个都是过期时间设置。\n\n一定要保证设置指定 key 的值和过期时间是一个原子操作！！！ 不然的话，依然可能会出现锁无法被释放的问题。\n这样确实可以解决问题，不过，这种解决办法同样存在漏洞：如果操作共享资源的时间大于过期时间，就会出现锁提前过期的问题，进而导致分布式锁直接失效。如果锁的超时时间设置过长，又会影响到性能。\n你或许在想： 如果操作共享资源的操作还未完成，锁过期时间能够自己续期就好了！\n如何实现锁的优雅续期？对于 Java 开发的小伙伴来说，已经有了现成的解决方案：**Redisson ** 。其他语言的解决方案，可以在 Redis 官方文档中找到.\nRedisson 是一个开源的 Java 语言 Redis 客户端，提供了很多开箱即用的功能，不仅仅包括多种分布式锁的实现。并且，Redisson 还支持 Redis 单机、Redis Sentinel 、Redis Cluster 等多种部署架构。\nRedisson 中的分布式锁自带自动续期机制，使用起来非常简单，原理也比较简单，其提供了一个专门用来监控和续期锁的 Watch Dog（ 看门狗），如果操作共享资源的线程还未执行完成的话，Watch Dog 会不断地延长锁的过期时间，进而保证锁不会因为超时而被释放。\n\n看门狗名字的由来于 getLockWatchdogTimeout() 方法，这个方法返回的是看门狗给锁续期的过期时间，默认为 30 秒（redisson-3.17.6 ）。\n//默认 30秒，支持修改private long lockWatchdogTimeout = 30 * 1000;public Config setLockWatchdogTimeout(long lockWatchdogTimeout) &#123;    this.lockWatchdogTimeout = lockWatchdogTimeout;    return this;&#125;public long getLockWatchdogTimeout() &#123;  \treturn lockWatchdogTimeout;&#125;\n\nrenewExpiration() 方法包含了看门狗的主要逻辑：\nprivate void renewExpiration() &#123;         //......        Timeout task = commandExecutor.getConnectionManager().newTimeout(new TimerTask() &#123;            @Override            public void run(Timeout timeout) throws Exception &#123;                //......                // 异步续期，基于 Lua 脚本                CompletionStage&lt;Boolean&gt; future = renewExpirationAsync(threadId);                future.whenComplete((res, e) -&gt; &#123;                    if (e != null) &#123;                        // 无法续期                        log.error(&quot;Can&#x27;t update lock &quot; + getRawName() + &quot; expiration&quot;, e);                        EXPIRATION_RENEWAL_MAP.remove(getEntryName());                        return;                    &#125;                    if (res) &#123;                        // 递归调用实现续期                        renewExpiration();                    &#125; else &#123;                        // 取消续期                        cancelExpirationRenewal(null);                    &#125;                &#125;);            &#125;         // 延迟 internalLockLeaseTime/3（默认 10s，也就是 30/3） 再调用        &#125;, internalLockLeaseTime / 3, TimeUnit.MILLISECONDS);        ee.setTimeout(task);    &#125;\n\n默认情况下，每过 10 秒，看门狗就会执行续期操作，将锁的超时时间设置为 30 秒。看门狗续期前也会先判断是否需要执行续期操作，需要才会执行续期，否则取消续期操作。\nWatch Dog 通过调用 renewExpirationAsync() 方法实现锁的异步续期：\nprotected CompletionStage&lt;Boolean&gt; renewExpirationAsync(long threadId) &#123;    return evalWriteAsync(getRawName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,            // 判断是否为持锁线程，如果是就执行续期操作，就锁的过期时间设置为 30s（默认）            &quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot; +                    &quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot; +                    &quot;return 1; &quot; +                    &quot;end; &quot; +                    &quot;return 0;&quot;,            Collections.singletonList(getRawName()),            internalLockLeaseTime, getLockName(threadId));&#125;\n\n可以看出， renewExpirationAsync 方法其实是调用 Lua 脚本实现的续期，这样做主要是为了保证续期操作的原子性。\n我这里以 Redisson 的分布式可重入锁 RLock 为例来说明如何使用 Redisson 实现分布式锁：\n// 1.获取指定的分布式锁对象RLock lock = redisson.getLock(&quot;lock&quot;);// 2.拿锁且不设置锁超时时间，具备 Watch Dog 自动续期机制lock.lock();// 3.执行业务...// 4.释放锁lock.unlock();\n\n只有未指定锁超时时间，才会使用到 Watch Dog 自动续期机制。\n// 手动给锁设置过期时间，不具备 Watch Dog 自动续期机制lock.lock(10, TimeUnit.SECONDS);\n\n如果使用 Redis 来实现分布式锁的话，还是比较推荐直接基于 Redisson 来做的。\n如何实现可重入锁？所谓可重入锁指的是在一个线程中可以多次获取同一把锁，比如一个线程在执行一个带锁的方法，该方法中又调用了另一个需要相同锁的方法，则该线程可以直接执行调用的方法即可重入 ，而无需重新获得锁。像 Java 中的 synchronized 和 ReentrantLock 都属于可重入锁。\n不可重入的分布式锁基本可以满足绝大部分业务场景了，一些特殊的场景可能会需要使用可重入的分布式锁。\n可重入分布式锁的实现核心思路是线程在获取锁的时候判断是否为自己的锁，如果是的话，就不用再重新获取了。为此，我们可以为每个锁关联一个可重入计数器和一个占有它的线程。当可重入计数器大于 0 时，则锁被占有，需要判断占有该锁的线程和请求获取锁的线程是否为同一个。\n实际项目中，我们不需要自己手动实现，推荐使用我们上面提到的 Redisson ，其内置了多种类型的锁比如可重入锁（Reentrant Lock）、自旋锁（Spin Lock）、公平锁（Fair Lock）、多重锁（MultiLock）、 红锁（RedLock）、 读写锁（ReadWriteLock）。\nRedis 如何解决集群情况下分布式锁的可靠性？为了避免单点故障，生产环境下的 Redis 服务通常是集群化部署的。\nRedis 集群下，上面介绍到的分布式锁的实现会存在一些问题。由于 Redis 集群数据同步到各个节点时是异步的，如果在 Redis 主节点获取到锁后，在没有同步到其他节点时，Redis 主节点宕机了，此时新的 Redis 主节点依然可以获取锁，所以多个应用服务就可以同时获取到锁。\n\n针对这个问题，Redis 之父 antirez 设计了 Redlock 算法  来解决.\nRedlock 算法的思想是让客户端向 Redis 集群中的多个独立的 Redis 实例依次请求申请加锁，如果客户端能够和半数以上的实例成功地完成加锁操作，那么我们就认为，客户端成功地获得分布式锁，否则加锁失败。\n即使部分 Redis 节点出现问题，只要保证 Redis 集群中有半数以上的 Redis 节点可用，分布式锁服务就是正常的。\nRedlock 是直接操作 Redis 节点的，并不是通过 Redis 集群操作的，这样才可以避免 Redis 集群主从切换导致的锁丢失问题。\nRedlock 实现比较复杂，性能比较差，发生时钟变迁的情况下还存在安全性隐患。《数据密集型应用系统设计》一书的作者 Martin Kleppmann 曾经专门发文（How to do distributed locking - Martin Kleppmann - 2016 ）怼过 Redlock，他认为这是一个很差的分布式锁实现。感兴趣的朋友可以看看Redis 锁从面试连环炮聊到神仙打架 这篇文章，有详细介绍到 antirez 和 Martin Kleppmann 关于 Redlock 的激烈辩论。\n实际项目中不建议使用 Redlock 算法，成本和收益不成正比。\n如果不是非要实现绝对可靠的分布式锁的话，其实单机版 Redis 就完全够了，实现简单，性能也非常高。如果你必须要实现一个绝对可靠的分布式锁的话，可以基于 ZooKeeper 来做，只是性能会差一些。\n基于 ZooKeeper 实现分布式锁\nRedis 实现分布式锁性能较高，ZooKeeper 实现分布式锁可靠性更高。实际项目中，我们应该根据业务的具体需求来选择。\n个人理解，Redis集群的情况下，可能会出现A客户端在Redis主节点获得锁，然后还没有同步其他节点时，主节点宕机，选举新的主节点，这种情况下B客户端可以从新的主节点获取锁。\n而Zookeeper是保证一致性的，所以不会出现这种问题。\n\n\n如何基于 ZooKeeper 实现分布式锁？ZooKeeper 分布式锁是基于 临时顺序节点 和 Watcher（事件监听器） 实现的。\n获取锁：\n\n首先我们要有一个持久节点/locks，客户端获取锁就是在locks下创建临时顺序节点。\n假设客户端 1 创建了/locks/lock1节点，创建成功之后，会判断 lock1是否是 /locks 下最小的子节点。\n如果 lock1是最小的子节点，则获取锁成功。否则，获取锁失败。\n如果获取锁失败，则说明有其他的客户端已经成功获取锁。客户端 1 并不会不停地循环去尝试加锁，而是在前一个节点比如/locks/lock0上注册一个事件监听器。这个监听器的作用是当前一个节点释放锁之后通知客户端 1（避免无效自旋），这样客户端 1 就加锁成功了。\n\n释放锁：\n\n成功获取锁的客户端在执行完业务流程之后，会将对应的子节点删除。\n成功获取锁的客户端在出现故障之后，对应的子节点由于是临时顺序节点（会话结束临时节点就会被删除），也会被自动删除，避免了锁无法被释放。\n我们前面说的事件监听器其实监听的就是这个子节点删除事件，子节点删除就意味着锁被释放。\n\n\n实际项目中，推荐使用 Curator 来实现 ZooKeeper 分布式锁。Curator 是 Netflix 公司开源的一套 ZooKeeper Java 客户端框架，相比于 ZooKeeper 自带的客户端 zookeeper 来说，Curator 的封装更加完善，各种 API 都可以比较方便地使用。\nCurator主要实现了下面四种锁：\n\nInterProcessMutex：分布式可重入排它锁\nInterProcessSemaphoreMutex：分布式不可重入排它锁\nInterProcessReadWriteLock：分布式读写锁\nInterProcessMultiLock：将多个锁作为单个实体管理的容器，获取锁的时候获取所有锁，释放锁也会释放所有锁资源（忽略释放失败的锁）。\n\nCuratorFramework client = ZKUtils.getClient();client.start();// 分布式可重入排它锁InterProcessLock lock1 = new InterProcessMutex(client, lockPath1);// 分布式不可重入排它锁InterProcessLock lock2 = new InterProcessSemaphoreMutex(client, lockPath2);// 将多个锁作为一个整体InterProcessMultiLock lock = new InterProcessMultiLock(Arrays.asList(lock1, lock2));if (!lock.acquire(10, TimeUnit.SECONDS)) &#123;  \tthrow new IllegalStateException(&quot;不能获取多锁&quot;);&#125;System.out.println(&quot;已获取多锁&quot;);System.out.println(&quot;是否有第一个锁: &quot; + lock1.isAcquiredInThisProcess());System.out.println(&quot;是否有第二个锁: &quot; + lock2.isAcquiredInThisProcess());try &#123;    // 资源操作 \t \t\tresource.use(); &#125; finally &#123;    System.out.println(&quot;释放多个锁&quot;);    lock.release(); &#125;System.out.println(&quot;是否有第一个锁: &quot; + lock1.isAcquiredInThisProcess());System.out.println(&quot;是否有第二个锁: &quot; + lock2.isAcquiredInThisProcess());client.close();\n\n为什么要用临时顺序节点？每个数据节点在 ZooKeeper 中被称为 znode，它是 ZooKeeper 中数据的最小单元。\n我们通常是将 znode 分为 4 大类：\n\n持久（PERSISTENT）节点 ：一旦创建就一直存在即使 ZooKeeper 集群宕机，直到将其删除。\n临时（EPHEMERAL）节点 ：临时节点的生命周期是与 客户端会话（session） 绑定的，会话消失则节点消失 。并且，临时节点只能做叶子节点 ，不能创建子节点。\n持久顺序（PERSISTENT_SEQUENTIAL）节点 ：除了具有持久（PERSISTENT）节点的特性之外， 子节点的名称还具有顺序性。比如 /node1/app0000000001 、/node1/app0000000002 。\n临时顺序（EPHEMERAL_SEQUENTIAL）节点 ：除了具备临时（EPHEMERAL）节点的特性之外，子节点的名称还具有顺序性。\n\n可以看出，临时节点相比持久节点，最主要的是对会话失效的情况处理不一样，临时节点会话消失则对应的节点消失。这样的话，如果客户端发生异常导致没来得及释放锁也没关系，会话失效节点自动被删除，不会发生死锁的问题。\n使用 Redis 实现分布式锁的时候，我们是通过过期时间来避免锁无法被释放导致死锁问题的，而 ZooKeeper 直接利用临时节点的特性即可。\n假设不使用顺序节点的话，所有尝试获取锁的客户端都会对持有锁的子节点加监听器。当该锁被释放之后，势必会造成所有尝试获取锁的客户端来争夺锁，这样对性能不友好。使用顺序节点之后，只需要监听前一个节点就好了，对性能更友好。\n为什么要设置对前一个节点的监听？\nWatcher（事件监听器），是 ZooKeeper 中的一个很重要的特性。ZooKeeper 允许用户在指定节点上注册一些 Watcher，并且在一些特定事件触发的时候，ZooKeeper 服务端会将事件通知到感兴趣的客户端上去，该机制是 ZooKeeper 实现分布式协调服务的重要特性。\n\n同一时间段内，可能会有很多客户端同时获取锁，但只有一个可以获取成功。如果获取锁失败，则说明有其他的客户端已经成功获取锁。获取锁失败的客户端并不会不停地循环去尝试加锁，而是在前一个节点注册一个事件监听器。\n这个事件监听器的作用是： 当前一个节点对应的客户端释放锁之后（也就是前一个节点被删除之后，监听的是删除事件），通知获取锁失败的客户端（唤醒等待的线程，Java 中的 wait/notifyAll ），让它尝试去获取锁，然后就成功获取锁了。\n总结这篇文章我们介绍了分布式锁的基本概念以及实现分布式锁的两种常见方式。至于具体选择 Redis 还是 ZooKeeper 来实现分布式锁，还是要看业务的具体需求。如果对性能要求比较高的话，建议使用 Redis 实现分布式锁。如果对可靠性要求比较高的话，建议使用 ZooKeeper 实现分布式锁。\n","categories":["Java","分布式"],"tags":["Redis","分布式锁","ZooKeeper"]},{"title":"项目部署到云服务器后漏洞修复","url":"/2023/05/26/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%88%B0%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%8E%E6%BC%8F%E6%B4%9E%E4%BF%AE%E5%A4%8D/","content":"部署到云服务器之后，发现有5个安全漏洞。\n需要根据修复方案自行修复\n\n\n\nApache Dubbo 漏洞修复将 Apache Dubbo 3.0.9 升级到 3.0.14 及以上版本\n&lt;!-- dubbo --&gt;&lt;dependency&gt;  &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;  &lt;artifactId&gt;dubbo&lt;/artifactId&gt;  &lt;version&gt;3.0.14&lt;/version&gt;&lt;/dependency&gt;\n\nFasterXML jackson-databind 漏洞修复查看 Maven 依赖发现是 Nacos 依赖了 FasterXML jackson-databind 2.13.3。\n需要排除掉 Nacos 中的 jackson-databind 和 jackson-core 2.13.3 依赖，自己引入 2.14.0 以上版本\n&lt;!-- nacos 注册中心 --&gt;&lt;dependency&gt;  &lt;groupId&gt;com.alibaba.nacos&lt;/groupId&gt;  &lt;artifactId&gt;nacos-client&lt;/artifactId&gt;  &lt;version&gt;2.2.0&lt;/version&gt;  &lt;!-- 排除掉nacos依赖的有高危漏洞的2.13jackson，自己引入 2.14.0以上的  --&gt;  &lt;exclusions&gt;    &lt;exclusion&gt;      &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;      &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;    &lt;/exclusion&gt;    &lt;exclusion&gt;      &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;      &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;    &lt;/exclusion&gt;  &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind --&gt;&lt;dependency&gt;  &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;  &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;  &lt;version&gt;2.14.2&lt;/version&gt;&lt;/dependency&gt;\n\nSpring Framework 身份认证绕过漏洞发现是 spring-webmvc-5.3.20 的问题，查看 Maven 依赖，是 spring-boot-starter-web:2.7.0 引入。\n\n直接将项目的 spring boot 版本升级到 2.7.11\n&lt;parent&gt;  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;  &lt;version&gt;2.7.11&lt;/version&gt;  &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;\n\n但升级之后下载不到 mysql-connector-java 的 jar包，因为我们没有指定版本。\n手动指定 mysql-connector-java 的版本即可解决\n&lt;!-- mysql--&gt;&lt;dependency&gt;  &lt;groupId&gt;mysql&lt;/groupId&gt;  &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;  &lt;!--为了修复Spring Framework漏洞 将Spring boot版本升到2.7.11后，  mysql-connector-java 找不到，只能指定版本--&gt;  &lt;version&gt;8.0.31&lt;/version&gt;  &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;\n\n","categories":["项目"],"tags":["项目部署","云服务器"]},{"title":"自定义注解+AOP实现权限管理","url":"/2023/05/26/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3+AOP%E5%AE%9E%E7%8E%B0%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/","content":"本文使用自定义注解和AOP面向切面编程实现权限管理。\n\n\n\n权限管理注解 @AuthCheck 及 AOP使用方法在需要校验权限的方法（控制器方法）上，加上 @AuthCheck 注解并指定该方法需要什么角色才能访问。\n\n如果没有权限进行操作，就会抛出异常。\n比如：\n\n在方法上使用注解（anyRole)\n\n@AuthCheck(anyRole = &#123;&quot;admin&quot;, &quot;user&quot;&#125;)\n\n最终在AuthInterceptor中，会校验，如果当前登录用户是 anyRole 数组中任一角色，即可访问被这个注解注解的方法。\n\n在方法上使用注解（mustRole)\n\n@AuthCheck(mustRole = &quot;admin&quot;)\n\n最终在AuthInterceptor中，会校验，如果当前登录用户是 mustRole 指定的角色，即可访问被这个注解注解的方法。\n源码学习AuthCheck 注解@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface AuthCheck &#123;    /**     * 有任何一个角色     *     * @return     */    String[] anyRole() default &quot;&quot;;    /**     * 必须有某个角色     *     * @return     */    String mustRole() default &quot;&quot;;&#125;\n\n一篇文章，全面掌握Java自定义注解（Annontation） \n注解的定义\n注解的定义通过@interface表示，所有的注解会自动继承java.lang.Annotation接口,且不能再继承别的类或是接口。\n注解的成员参数只能用public或默认(default) 访问权修饰来进行修饰。\n成员参数只能使用八种基本类型（byte、short、char、int、long、float、double、boolean）和String、Enum、Class、annotations等数据类型，及其数组。\n获取类方法和字段的注解信息，只能通过Java的反射技术来获取 Annotation 对象。\n注解可以没有定义成员，只做标识。\n\n元注解**@Target**和**@Retention**是元注解（注解其他注解的注解）\n\n@Documented – 注解是否将包含在JavaDoc中\n@Retention – 注解的生命周期\n@Target – 注解用于什么地方\n@Inherited – 是否允许子类继承该注解\n@Repeatable - 是否可重复注解，jdk1.8引入\n\n注解的生命周期通过@Retention定义注解的生命周期，格式如下：\n@Retention(RetentionPolicy.SOURCE)\n\n其中RetentionPolicy的不同策略对应的生命周期如下：\n\nRetentionPolicy.SOURCE : 仅存在于源代码中，编译阶段会被丢弃，不会包含于class字节码文件中。@Override, @SuppressWarnings都属于这类注解。\nRetentionPolicy.CLASS : 默认策略，在class字节码文件中存在，在类加载的时被丢弃，运行时无法获取到。\nRetentionPolicy.RUNTIME : 始终不会丢弃，可以使用反射获得该注解的信息。自定义的注解最常用的使用方式。\n\n注解的作用目标通过@Target定义注解作用的目标，比如作用于类、属性、或方法等，默认可用于任何地方。格式如下：\n@Target(ElementType.TYPE)\n\n对应ElementType参数值适用范围如下：\n\nElementType.TYPE: 类、接口、注解、enum\nElementType.CONSTRUCTOR: 构造函数\nElementType.FIELD: 成员变量、对象、属性、枚举的常量\nElementType.LOCAL_VARIABLE: 局部变量\nElementType.METHOD: 方法\nElementType.PACKAGE: 包\nElementType.PARAMETER: 参数\nElementType.ANNOTATION_TYPE): 注解\nElementType.TYPE_PARAMETER：类型参数，表示这个注解可以用在 Type的声明式前,jdk1.8引入。\nElementType.TYPE_USE：类型的注解，表示这个注解可以用在所有使用Type的地方（如：泛型，类型转换等），jdk1.8引入。\n\nAOP 实现权限管理拦截器@Aspect@Componentpublic class AuthInterceptor &#123;    @Resource    private UserService userService;    /**     * 执行拦截     *     * @param joinPoint     * @param authCheck     * @return     */    @Around(&quot;@annotation(authCheck)&quot;)    public Object doInterceptor(ProceedingJoinPoint joinPoint, AuthCheck authCheck) throws Throwable &#123;        // 获取注解的 anyRole数组, 将其转换为 List        List&lt;String&gt; anyRole = Arrays.stream(authCheck.anyRole()).filter(StringUtils::isNotBlank).collect(Collectors.toList());        // 获取注解的 mustRole        String mustRole = authCheck.mustRole();        // 获取当前登录用户        RequestAttributes requestAttributes = RequestContextHolder.currentRequestAttributes();        HttpServletRequest request = ((ServletRequestAttributes) requestAttributes).getRequest();        User user = userService.getLoginUser(request);        // 拥有anyRole中任意权限即通过        if (CollectionUtils.isNotEmpty(anyRole)) &#123;            String userRole = user.getUserRole();            if (!anyRole.contains(userRole)) &#123;                throw new BusinessException(ErrorCode.NO_AUTH_ERROR);            &#125;        &#125;        // 必须有所有权限才通过        if (StringUtils.isNotBlank(mustRole)) &#123;            String userRole = user.getUserRole();            if (!mustRole.equals(userRole)) &#123;                throw new BusinessException(ErrorCode.NO_AUTH_ERROR);            &#125;        &#125;        // 通过权限校验，放行        return joinPoint.proceed();    &#125;&#125;\n\n数据库 user 表中，有一个 varChar 类型的 userRole 字段。\n更完善的权限管理方法，应该使用 RBAC 模型，即数据库要有 权限表、角色表、用户表、角色权限表、用户角色表。而鱼皮这里只是简单使用一个字段表示用户角色。\n完美的方案参考：\nspringboot+自定义注解+AOP实现权限控制（一） \nspringboot+自定义注解+AOP实现权限控制（二） \n","categories":["Java"],"tags":["注解","AOP"]}]