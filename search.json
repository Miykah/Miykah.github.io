[{"title":"乐观锁和悲观锁","url":"/2023/05/29/%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81/","content":"什么是悲观锁？悲观锁总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。也就是说，共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程。\n像 Java 中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。\npublic void performSynchronisedTask() &#123;    synchronized (this) &#123;        // 需要同步的操作    &#125;&#125;private Lock lock = new ReentrantLock();lock.lock();try &#123;   // 需要同步的操作&#125; finally &#123;    lock.unlock();&#125;\n\n高并发的场景下，激烈的锁竞争会造成线程阻塞，大量阻塞线程会导致系统的上下文切换，增加系统的性能开销。并且，悲观锁还可能会存在死锁问题，影响代码的正常运行。\n什么是乐观锁？乐观锁总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源（也就是数据）是否被其它线程修改了（具体方法可以使用版本号机制或 CAS 算法）。\n在 Java 中java.util.concurrent.atomic包下面的原子变量类（比如AtomicInteger、LongAdder）就是使用了乐观锁的一种实现方式 CAS 实现的。\n\n// LongAdder 在高并发场景下会比 AtomicInteger 和 AtomicLong 的性能更好// 代价就是会消耗更多的内存空间（空间换时间）LongAdder sum = new LongAdder();sum.increment();\n\n高并发的场景下，乐观锁相比悲观锁来说，不存在锁竞争造成线程阻塞，也不会有死锁的问题，在性能上往往会更胜一筹。但是，如果冲突频繁发生（写占比非常多的情况），会频繁失败和重试，这样同样会非常影响性能，导致 CPU 飙升。\n不过，大量失败重试的问题也是可以解决的，像我们前面提到的 LongAdder以空间换时间的方式就解决了这个问题。\n理论上来说：\n\n悲观锁通常多用于写比较多的情况下（多写场景，竞争激烈），这样可以避免频繁失败和重试影响性能，悲观锁的开销是固定的。不过，如果乐观锁解决了频繁失败和重试这个问题的话（比如LongAdder），也是可以考虑使用乐观锁的，要视实际情况而定。\n乐观锁通常多于写比较少的情况下（多读场景，竞争较少），这样可以避免频繁加锁影响性能。不过，乐观锁主要针对的对象是单个共享变量（参考java.util.concurrent.atomic包下面的原子变量类）。\n\n如何实现乐观锁？乐观锁一般会使用版本号机制或 CAS 算法实现，CAS 算法相对来说更多一些，这里需要格外注意。\n版本号机制一般是在数据表中加上一个数据版本号 version 字段，表示数据被修改的次数。当数据被修改时，version 值会加一。当线程 A 要更新数据值时，在读取数据的同时也会读取 version 值，在提交更新时，若刚才读取到的 version 值为当前数据库中的 version 值相等时才更新，否则重试更新操作，直到更新成功。\n举一个简单的例子：假设数据库中帐户信息表中有一个 version 字段，当前值为 1 ；而当前帐户余额字段（ balance ）为 $100 。\n\n操作员 A 此时将其读出（ version&#x3D;1 ），并从其帐户余额中扣除 $50（ $100-$50 ）。\n在操作员 A 操作的过程中，操作员 B 也读入此用户信息（ version&#x3D;1 ），并从其帐户余额中扣除 $20 （ $100-$20 ）。\n操作员 A 完成了修改工作，将数据版本号（ version&#x3D;1 ），连同帐户扣除后余额（ balance&#x3D;$50 ），提交至数据库更新，此时由于提交数据版本等于数据库记录当前版本，数据被更新，数据库记录 version 更新为 2 。\n操作员 B 完成了操作，也将版本号（ version&#x3D;1 ）试图向数据库提交数据（ balance&#x3D;$80 ），但此时比对数据库记录版本时发现，操作员 B 提交的数据版本号为 1 ，数据库记录当前版本也为 2 ，不满足 “ 提交版本必须等于当前版本才能执行更新 “ 的乐观锁策略，因此，操作员 B 的提交被驳回。\n\n这样就避免了操作员 B 用基于 version&#x3D;1 的旧数据修改的结果覆盖操作员 A 的操作结果的可能。\nCAS 算法CAS 的全称是 Compare And Swap（比较与交换） ，用于实现乐观锁，被广泛应用于各大框架中。CAS 的思想很简单，就是用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。\nCAS 是一个原子操作，底层依赖于一条 CPU 的原子指令。\n\n原子操作 即最小不可拆分的操作，也就是说操作一旦开始，就不能被打断，直到操作完成。\n\nCAS 涉及到三个操作数：\n\nV：要更新的变量值(Var)\nE：预期值(Expected)\nN：拟写入的新值(New)\n\n当且仅当 V 的值等于 E 时，CAS 通过原子方式用新值 N 来更新 V 的值。如果不等，说明已经有其它线程更新了 V，则当前线程放弃更新。\n举一个简单的例子：线程 A 要修改变量 i 的值为 6，i 原值为 1（V &#x3D; 1，E&#x3D;1，N&#x3D;6，假设不存在 ABA 问题）。\n\ni 与 1 进行比较，如果相等， 则说明没被其他线程修改，可以被设置为 6 。\ni 与 1 进行比较，如果不相等，则说明被其他线程修改，当前线程放弃更新，CAS 操作失败。\n\n当多个线程同时使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。\nJava 语言并没有直接实现 CAS，CAS 相关的实现是通过 C++ 内联汇编的形式实现的（JNI 调用）。因此， CAS 的具体实现和操作系统以及 CPU 都有关系。\nsun.misc包下的Unsafe类提供了compareAndSwapObject、compareAndSwapInt、compareAndSwapLong方法来实现的对Object、int、long类型的 CAS 操作\n/**\t*  CAS  * @param o         包含要修改field的对象  * @param offset    对象中某field的偏移量  * @param expected  期望值  * @param update    更新值  * @return          true | false  */public final native boolean compareAndSwapObject(Object o, long offset,  Object expected, Object update);public final native boolean compareAndSwapInt(Object o, long offset, int expected,int update);public final native boolean compareAndSwapLong(Object o, long offset, long expected, long update);\n\n乐观锁存在哪些问题？ABA 问题是乐观锁最常见的问题。\nABA 问题如果一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然是 A 值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回 A，那 CAS 操作就会误认为它从来没有被修改过。这个问题被称为 CAS 操作的 “ABA”问题。\nABA 问题的解决思路是在变量前面追加上版本号或者时间戳。JDK 1.5 以后的 AtomicStampedReference 类就是用来解决 ABA 问题的，其中的 compareAndSet() 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。\npublic boolean compareAndSet(V   expectedReference,                             V   newReference,                             int expectedStamp,                             int newStamp) &#123;    Pair&lt;V&gt; current = pair;    return        expectedReference == current.reference &amp;&amp;        expectedStamp == current.stamp &amp;&amp;        ((newReference == current.reference &amp;&amp;          newStamp == current.stamp) ||         casPair(current, Pair.of(newReference, newStamp)));&#125;\n\n循环时间长开销大CAS 经常会用到自旋操作来进行重试，也就是不成功就一直循环执行直到成功。如果长时间不成功，会给 CPU 带来非常大的执行开销。\n如果 JVM 能支持处理器提供的 pause 指令那么效率会有一定的提升，pause 指令有两个作用：\n\n可以延迟流水线执行指令，使 CPU 不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。\n可以避免在退出循环的时候因内存顺序冲而引起 CPU 流水线被清空，从而提高 CPU 的执行效率。\n\n只能保证一个共享变量的原子操作CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5 开始，提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用\n","categories":["Java"],"tags":["锁","并发"]},{"title":"Hexo配置Waline评论系统","url":"/2023/05/27/Hexo%E9%85%8D%E7%BD%AEWaline%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/","content":"评论系统选择Waline 是一款简洁、安全的评论系统。\n具有管理评论和Reaction的功能。如图：\n\n\nHexo-Keep主题配置Waline评论系统根据 Waline 文档部署 LeanCloud 数据库和 Vercel 服务端https://waline.js.org/guide/get-started/ \n修改主题配置文件 _config.yml\n启用评论，并使用 waline 评论系统\ncomment:  enable: true   # Option values: true | false  use: waline     # Option values: valine | gitalk | twikoo | waline\n\n配置 waline\nserver_url 是成功部署 Waline 评论系统的服务端地址。\nreaction 设置开启文章反应，可选值：true 或 false。\nversion 设置 Waline 评论系统版本，Keep 主题内置使用 Waline v2，你可以自行更改。\nwaline:  server_url: https://comment-waline-server-qk96wik8t-miykah.vercel.app/ # Server URL  reaction: true # Article reactions, Option values: true | false  version: 2      # Waline version, default use v2\n\n评论系统启用成功\n\n\n\n评论系统与管理系统\n评论系统：example.yourdomain.com      我的：https://comment.miykah.top/ \n评论管理：example.yourdomain.com&#x2F;ui   我的：https://comment.miykah.top/ui \n\n评论管理系统可以进行评论管理以及用户管理：\n\n\n\n问题只有在挂了梯子之后才能流畅访问\n不连接梯子的情况下， 博客的评论一直加载不出来，百度了一下，发现是 vercel.app 的域名问题。\nhttps://blog.csdn.net/Panzer_Jack/article/details/127418379 \n\n解决办法\n参考：\nhttps://blog.csdn.net/Panzer_Jack/article/details/127418379 \nhttps://waline.js.org/guide/get-started/#%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D-%E5%8F%AF%E9%80%89 \n\n\n首先需要有一个域名，比如我有一个 miykah.top 域名\n\n域名解析添加记录：取一个二级域名为 comment ，记录值为 cname.vercel-dns.com \n\n\n在vercel部署的服务端中绑定域名 comment.miykah.top\n\n\n\n修改主题配置文件 _config.yml\nwaline:  server_url: https://comment.miykah.top/ # 改为绑定的评论系统新域名  reaction: true # Article reactions, Option values: true | false  version: 2      # Waline version, default use v2\n\n问题解决！不挂梯子也能加载出评论！\n\n\n进阶配置邮件通知参考：\nhttps://waline.js.org/guide/features/notification.html#%E9%82%AE%E4%BB%B6%E9%80%9A%E7%9F%A5 \nhttps://oragekk.me/blog/waline-mail.html \n","categories":["博客搭建"],"tags":["waline","Hexo"]},{"title":"如何实现分布式锁？","url":"/2023/05/27/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%EF%BC%9F/","content":"\n本文源自 https://javaguide.cn/ \n\n分布式锁介绍对于单机多线程来说，在 Java 中，我们通常使用 ReetrantLock 类、synchronized 关键字这类 JDK 自带的 本地锁 来控制一个 JVM 进程内的多个线程对本地共享资源的访问。\n下面是我对本地锁画的一张示意图。\n\n从图中可以看出，这些线程访问共享资源是互斥的，同一时刻只有一个线程可以获取到本地锁访问共享资源。\n分布式系统下，不同的服务&#x2F;客户端通常运行在独立的 JVM 进程上。如果多个 JVM 进程共享同一份资源的话，使用本地锁就没办法实现资源的互斥访问了。于是，分布式锁 就诞生了。\n举个例子：系统的订单服务一共部署了 3 份，都对外提供服务。用户下订单之前需要检查库存，为了防止超卖，这里需要加锁以实现对检查库存操作的同步访问。由于订单服务位于不同的 JVM 进程中，本地锁在这种情况下就没办法正常工作了。我们需要用到分布式锁，这样的话，即使多个线程不在同一个 JVM 进程中也能获取到同一把锁，进而实现共享资源的互斥访问。\n下面是我对分布式锁画的一张示意图。\n\n从图中可以看出，这些独立的进程中的线程访问共享资源是互斥的，同一时刻只有一个线程可以获取到分布式锁访问共享资源。\n一个最基本的分布式锁需要满足：\n\n互斥 ：任意一个时刻，锁只能被一个线程持有；\n高可用 ：锁服务是高可用的。并且，即使客户端的释放锁的代码逻辑出现问题，锁最终一定还是会被释放，不会影响其他线程对共享资源的访问。\n可重入：一个节点获取了锁之后，还可以再次获取锁。\n\n通常情况下，我们一般会选择基于 Redis 或者 ZooKeeper 实现分布式锁，Redis 用的要更多一点，我这里也以 Redis 为例介绍分布式锁的实现。\n基于 Redis 实现分布式锁如何基于 Redis 实现一个最简易的分布式锁？不论是本地锁还是分布式锁，核心都在于“互斥”。\n在 Redis 中， SETNX 命令是可以帮助我们实现互斥。SETNX 即 SET if Not eXists (对应 Java 中的 setIfAbsent 方法)，如果 key 不存在的话，才会设置 key 的值。如果 key 已经存在， SETNX 啥也不做。\n&gt; SETNX lockKey uniqueValue(integer) 1&gt; SETNX lockKey uniqueValue(integer) 0\n\n释放锁的话，直接通过 DEL 命令删除对应的 key 即可。\n&gt; DEL lockKey(integer) 1\n\n为了防止误删到其他的锁，这里我们建议使用 Lua 脚本通过 key 对应的 value（唯一值）来判断。\n选用 Lua 脚本是为了保证解锁操作的原子性。因为 Redis 在执行 Lua 脚本时，可以以原子性的方式执行，从而保证了锁释放操作的原子性。\n// 释放锁时，先比较锁对应的 value 值是否相等，避免锁的误释放if redis.call(&quot;get&quot;,KEYS[1]) == ARGV[1] then    return redis.call(&quot;del&quot;,KEYS[1])else    return 0end\n\n\n这是一种最简易的 Redis 分布式锁实现，实现方式比较简单，性能也很高效。不过，这种方式实现分布式锁存在一些问题。就比如应用程序遇到一些问题比如释放锁的逻辑突然挂掉，可能会导致锁无法被释放，进而造成共享资源无法再被其他线程&#x2F;进程访问。\n为什么要给锁设置一个过期时间？为了避免锁无法被释放，我们可以想到的一个解决办法就是： 给这个 key（也就是锁） 设置一个过期时间 。\n127.0.0.1:6379&gt; SET lockKey uniqueValue EX 3 NXOK\n\n\nlockKey ：加锁的锁名；\nuniqueValue ：能够唯一标示锁的随机字符串；\nNX ：只有当 lockKey 对应的 key 值不存在的时候才能 SET 成功；\nEX ：过期时间设置（秒为单位）EX 3 标示这个锁有一个 3 秒的自动过期时间。与 EX 对应的是 PX（毫秒为单位），这两个都是过期时间设置。\n\n一定要保证设置指定 key 的值和过期时间是一个原子操作！！！ 不然的话，依然可能会出现锁无法被释放的问题。\n这样确实可以解决问题，不过，这种解决办法同样存在漏洞：如果操作共享资源的时间大于过期时间，就会出现锁提前过期的问题，进而导致分布式锁直接失效。如果锁的超时时间设置过长，又会影响到性能。\n你或许在想： 如果操作共享资源的操作还未完成，锁过期时间能够自己续期就好了！\n如何实现锁的优雅续期？对于 Java 开发的小伙伴来说，已经有了现成的解决方案：**Redisson ** 。其他语言的解决方案，可以在 Redis 官方文档中找到.\nRedisson 是一个开源的 Java 语言 Redis 客户端，提供了很多开箱即用的功能，不仅仅包括多种分布式锁的实现。并且，Redisson 还支持 Redis 单机、Redis Sentinel 、Redis Cluster 等多种部署架构。\nRedisson 中的分布式锁自带自动续期机制，使用起来非常简单，原理也比较简单，其提供了一个专门用来监控和续期锁的 Watch Dog（ 看门狗），如果操作共享资源的线程还未执行完成的话，Watch Dog 会不断地延长锁的过期时间，进而保证锁不会因为超时而被释放。\n\n看门狗名字的由来于 getLockWatchdogTimeout() 方法，这个方法返回的是看门狗给锁续期的过期时间，默认为 30 秒（redisson-3.17.6 ）。\n//默认 30秒，支持修改private long lockWatchdogTimeout = 30 * 1000;public Config setLockWatchdogTimeout(long lockWatchdogTimeout) &#123;    this.lockWatchdogTimeout = lockWatchdogTimeout;    return this;&#125;public long getLockWatchdogTimeout() &#123;  \treturn lockWatchdogTimeout;&#125;\n\nrenewExpiration() 方法包含了看门狗的主要逻辑：\nprivate void renewExpiration() &#123;         //......        Timeout task = commandExecutor.getConnectionManager().newTimeout(new TimerTask() &#123;            @Override            public void run(Timeout timeout) throws Exception &#123;                //......                // 异步续期，基于 Lua 脚本                CompletionStage&lt;Boolean&gt; future = renewExpirationAsync(threadId);                future.whenComplete((res, e) -&gt; &#123;                    if (e != null) &#123;                        // 无法续期                        log.error(&quot;Can&#x27;t update lock &quot; + getRawName() + &quot; expiration&quot;, e);                        EXPIRATION_RENEWAL_MAP.remove(getEntryName());                        return;                    &#125;                    if (res) &#123;                        // 递归调用实现续期                        renewExpiration();                    &#125; else &#123;                        // 取消续期                        cancelExpirationRenewal(null);                    &#125;                &#125;);            &#125;         // 延迟 internalLockLeaseTime/3（默认 10s，也就是 30/3） 再调用        &#125;, internalLockLeaseTime / 3, TimeUnit.MILLISECONDS);        ee.setTimeout(task);    &#125;\n\n默认情况下，每过 10 秒，看门狗就会执行续期操作，将锁的超时时间设置为 30 秒。看门狗续期前也会先判断是否需要执行续期操作，需要才会执行续期，否则取消续期操作。\nWatch Dog 通过调用 renewExpirationAsync() 方法实现锁的异步续期：\nprotected CompletionStage&lt;Boolean&gt; renewExpirationAsync(long threadId) &#123;    return evalWriteAsync(getRawName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,            // 判断是否为持锁线程，如果是就执行续期操作，就锁的过期时间设置为 30s（默认）            &quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot; +                    &quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot; +                    &quot;return 1; &quot; +                    &quot;end; &quot; +                    &quot;return 0;&quot;,            Collections.singletonList(getRawName()),            internalLockLeaseTime, getLockName(threadId));&#125;\n\n可以看出， renewExpirationAsync 方法其实是调用 Lua 脚本实现的续期，这样做主要是为了保证续期操作的原子性。\n我这里以 Redisson 的分布式可重入锁 RLock 为例来说明如何使用 Redisson 实现分布式锁：\n// 1.获取指定的分布式锁对象RLock lock = redisson.getLock(&quot;lock&quot;);// 2.拿锁且不设置锁超时时间，具备 Watch Dog 自动续期机制lock.lock();// 3.执行业务...// 4.释放锁lock.unlock();\n\n只有未指定锁超时时间，才会使用到 Watch Dog 自动续期机制。\n// 手动给锁设置过期时间，不具备 Watch Dog 自动续期机制lock.lock(10, TimeUnit.SECONDS);\n\n如果使用 Redis 来实现分布式锁的话，还是比较推荐直接基于 Redisson 来做的。\n如何实现可重入锁？所谓可重入锁指的是在一个线程中可以多次获取同一把锁，比如一个线程在执行一个带锁的方法，该方法中又调用了另一个需要相同锁的方法，则该线程可以直接执行调用的方法即可重入 ，而无需重新获得锁。像 Java 中的 synchronized 和 ReentrantLock 都属于可重入锁。\n不可重入的分布式锁基本可以满足绝大部分业务场景了，一些特殊的场景可能会需要使用可重入的分布式锁。\n可重入分布式锁的实现核心思路是线程在获取锁的时候判断是否为自己的锁，如果是的话，就不用再重新获取了。为此，我们可以为每个锁关联一个可重入计数器和一个占有它的线程。当可重入计数器大于 0 时，则锁被占有，需要判断占有该锁的线程和请求获取锁的线程是否为同一个。\n实际项目中，我们不需要自己手动实现，推荐使用我们上面提到的 Redisson ，其内置了多种类型的锁比如可重入锁（Reentrant Lock）、自旋锁（Spin Lock）、公平锁（Fair Lock）、多重锁（MultiLock）、 红锁（RedLock）、 读写锁（ReadWriteLock）。\nRedis 如何解决集群情况下分布式锁的可靠性？为了避免单点故障，生产环境下的 Redis 服务通常是集群化部署的。\nRedis 集群下，上面介绍到的分布式锁的实现会存在一些问题。由于 Redis 集群数据同步到各个节点时是异步的，如果在 Redis 主节点获取到锁后，在没有同步到其他节点时，Redis 主节点宕机了，此时新的 Redis 主节点依然可以获取锁，所以多个应用服务就可以同时获取到锁。\n\n针对这个问题，Redis 之父 antirez 设计了 Redlock 算法  来解决.\nRedlock 算法的思想是让客户端向 Redis 集群中的多个独立的 Redis 实例依次请求申请加锁，如果客户端能够和半数以上的实例成功地完成加锁操作，那么我们就认为，客户端成功地获得分布式锁，否则加锁失败。\n即使部分 Redis 节点出现问题，只要保证 Redis 集群中有半数以上的 Redis 节点可用，分布式锁服务就是正常的。\nRedlock 是直接操作 Redis 节点的，并不是通过 Redis 集群操作的，这样才可以避免 Redis 集群主从切换导致的锁丢失问题。\nRedlock 实现比较复杂，性能比较差，发生时钟变迁的情况下还存在安全性隐患。《数据密集型应用系统设计》一书的作者 Martin Kleppmann 曾经专门发文（How to do distributed locking - Martin Kleppmann - 2016 ）怼过 Redlock，他认为这是一个很差的分布式锁实现。感兴趣的朋友可以看看Redis 锁从面试连环炮聊到神仙打架 这篇文章，有详细介绍到 antirez 和 Martin Kleppmann 关于 Redlock 的激烈辩论。\n实际项目中不建议使用 Redlock 算法，成本和收益不成正比。\n如果不是非要实现绝对可靠的分布式锁的话，其实单机版 Redis 就完全够了，实现简单，性能也非常高。如果你必须要实现一个绝对可靠的分布式锁的话，可以基于 ZooKeeper 来做，只是性能会差一些。\n基于 ZooKeeper 实现分布式锁\nRedis 实现分布式锁性能较高，ZooKeeper 实现分布式锁可靠性更高。实际项目中，我们应该根据业务的具体需求来选择。\n个人理解，Redis集群的情况下，可能会出现A客户端在Redis主节点获得锁，然后还没有同步其他节点时，主节点宕机，选举新的主节点，这种情况下B客户端可以从新的主节点获取锁。\n而Zookeeper是保证一致性的，所以不会出现这种问题。\n\n\n如何基于 ZooKeeper 实现分布式锁？ZooKeeper 分布式锁是基于 临时顺序节点 和 Watcher（事件监听器） 实现的。\n获取锁：\n\n首先我们要有一个持久节点/locks，客户端获取锁就是在locks下创建临时顺序节点。\n假设客户端 1 创建了/locks/lock1节点，创建成功之后，会判断 lock1是否是 /locks 下最小的子节点。\n如果 lock1是最小的子节点，则获取锁成功。否则，获取锁失败。\n如果获取锁失败，则说明有其他的客户端已经成功获取锁。客户端 1 并不会不停地循环去尝试加锁，而是在前一个节点比如/locks/lock0上注册一个事件监听器。这个监听器的作用是当前一个节点释放锁之后通知客户端 1（避免无效自旋），这样客户端 1 就加锁成功了。\n\n释放锁：\n\n成功获取锁的客户端在执行完业务流程之后，会将对应的子节点删除。\n成功获取锁的客户端在出现故障之后，对应的子节点由于是临时顺序节点（会话结束临时节点就会被删除），也会被自动删除，避免了锁无法被释放。\n我们前面说的事件监听器其实监听的就是这个子节点删除事件，子节点删除就意味着锁被释放。\n\n\n实际项目中，推荐使用 Curator 来实现 ZooKeeper 分布式锁。Curator 是 Netflix 公司开源的一套 ZooKeeper Java 客户端框架，相比于 ZooKeeper 自带的客户端 zookeeper 来说，Curator 的封装更加完善，各种 API 都可以比较方便地使用。\nCurator主要实现了下面四种锁：\n\nInterProcessMutex：分布式可重入排它锁\nInterProcessSemaphoreMutex：分布式不可重入排它锁\nInterProcessReadWriteLock：分布式读写锁\nInterProcessMultiLock：将多个锁作为单个实体管理的容器，获取锁的时候获取所有锁，释放锁也会释放所有锁资源（忽略释放失败的锁）。\n\nCuratorFramework client = ZKUtils.getClient();client.start();// 分布式可重入排它锁InterProcessLock lock1 = new InterProcessMutex(client, lockPath1);// 分布式不可重入排它锁InterProcessLock lock2 = new InterProcessSemaphoreMutex(client, lockPath2);// 将多个锁作为一个整体InterProcessMultiLock lock = new InterProcessMultiLock(Arrays.asList(lock1, lock2));if (!lock.acquire(10, TimeUnit.SECONDS)) &#123;  \tthrow new IllegalStateException(&quot;不能获取多锁&quot;);&#125;System.out.println(&quot;已获取多锁&quot;);System.out.println(&quot;是否有第一个锁: &quot; + lock1.isAcquiredInThisProcess());System.out.println(&quot;是否有第二个锁: &quot; + lock2.isAcquiredInThisProcess());try &#123;    // 资源操作 \t \t\tresource.use(); &#125; finally &#123;    System.out.println(&quot;释放多个锁&quot;);    lock.release(); &#125;System.out.println(&quot;是否有第一个锁: &quot; + lock1.isAcquiredInThisProcess());System.out.println(&quot;是否有第二个锁: &quot; + lock2.isAcquiredInThisProcess());client.close();\n\n为什么要用临时顺序节点？每个数据节点在 ZooKeeper 中被称为 znode，它是 ZooKeeper 中数据的最小单元。\n我们通常是将 znode 分为 4 大类：\n\n持久（PERSISTENT）节点 ：一旦创建就一直存在即使 ZooKeeper 集群宕机，直到将其删除。\n临时（EPHEMERAL）节点 ：临时节点的生命周期是与 客户端会话（session） 绑定的，会话消失则节点消失 。并且，临时节点只能做叶子节点 ，不能创建子节点。\n持久顺序（PERSISTENT_SEQUENTIAL）节点 ：除了具有持久（PERSISTENT）节点的特性之外， 子节点的名称还具有顺序性。比如 /node1/app0000000001 、/node1/app0000000002 。\n临时顺序（EPHEMERAL_SEQUENTIAL）节点 ：除了具备临时（EPHEMERAL）节点的特性之外，子节点的名称还具有顺序性。\n\n可以看出，临时节点相比持久节点，最主要的是对会话失效的情况处理不一样，临时节点会话消失则对应的节点消失。这样的话，如果客户端发生异常导致没来得及释放锁也没关系，会话失效节点自动被删除，不会发生死锁的问题。\n使用 Redis 实现分布式锁的时候，我们是通过过期时间来避免锁无法被释放导致死锁问题的，而 ZooKeeper 直接利用临时节点的特性即可。\n假设不使用顺序节点的话，所有尝试获取锁的客户端都会对持有锁的子节点加监听器。当该锁被释放之后，势必会造成所有尝试获取锁的客户端来争夺锁，这样对性能不友好。使用顺序节点之后，只需要监听前一个节点就好了，对性能更友好。\n为什么要设置对前一个节点的监听？\nWatcher（事件监听器），是 ZooKeeper 中的一个很重要的特性。ZooKeeper 允许用户在指定节点上注册一些 Watcher，并且在一些特定事件触发的时候，ZooKeeper 服务端会将事件通知到感兴趣的客户端上去，该机制是 ZooKeeper 实现分布式协调服务的重要特性。\n\n同一时间段内，可能会有很多客户端同时获取锁，但只有一个可以获取成功。如果获取锁失败，则说明有其他的客户端已经成功获取锁。获取锁失败的客户端并不会不停地循环去尝试加锁，而是在前一个节点注册一个事件监听器。\n这个事件监听器的作用是： 当前一个节点对应的客户端释放锁之后（也就是前一个节点被删除之后，监听的是删除事件），通知获取锁失败的客户端（唤醒等待的线程，Java 中的 wait/notifyAll ），让它尝试去获取锁，然后就成功获取锁了。\n总结这篇文章我们介绍了分布式锁的基本概念以及实现分布式锁的两种常见方式。至于具体选择 Redis 还是 ZooKeeper 来实现分布式锁，还是要看业务的具体需求。如果对性能要求比较高的话，建议使用 Redis 实现分布式锁。如果对可靠性要求比较高的话，建议使用 ZooKeeper 实现分布式锁。\n","categories":["Java","分布式"],"tags":["分布式锁","Redis","ZooKeeper"]},{"title":"自定义注解+AOP实现权限管理","url":"/2023/05/26/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3+AOP%E5%AE%9E%E7%8E%B0%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/","content":"本文使用自定义注解和AOP面向切面编程实现权限管理。\n\n\n\n权限管理注解 @AuthCheck 及 AOP使用方法在需要校验权限的方法（控制器方法）上，加上 @AuthCheck 注解并指定该方法需要什么角色才能访问。\n\n如果没有权限进行操作，就会抛出异常。\n比如：\n\n在方法上使用注解（anyRole)\n\n@AuthCheck(anyRole = &#123;&quot;admin&quot;, &quot;user&quot;&#125;)\n\n最终在AuthInterceptor中，会校验，如果当前登录用户是 anyRole 数组中任一角色，即可访问被这个注解注解的方法。\n\n在方法上使用注解（mustRole)\n\n@AuthCheck(mustRole = &quot;admin&quot;)\n\n最终在AuthInterceptor中，会校验，如果当前登录用户是 mustRole 指定的角色，即可访问被这个注解注解的方法。\n源码学习AuthCheck 注解@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface AuthCheck &#123;    /**     * 有任何一个角色     *     * @return     */    String[] anyRole() default &quot;&quot;;    /**     * 必须有某个角色     *     * @return     */    String mustRole() default &quot;&quot;;&#125;\n\n一篇文章，全面掌握Java自定义注解（Annontation） \n注解的定义\n注解的定义通过@interface表示，所有的注解会自动继承java.lang.Annotation接口,且不能再继承别的类或是接口。\n注解的成员参数只能用public或默认(default) 访问权修饰来进行修饰。\n成员参数只能使用八种基本类型（byte、short、char、int、long、float、double、boolean）和String、Enum、Class、annotations等数据类型，及其数组。\n获取类方法和字段的注解信息，只能通过Java的反射技术来获取 Annotation 对象。\n注解可以没有定义成员，只做标识。\n\n元注解**@Target**和**@Retention**是元注解（注解其他注解的注解）\n\n@Documented – 注解是否将包含在JavaDoc中\n@Retention – 注解的生命周期\n@Target – 注解用于什么地方\n@Inherited – 是否允许子类继承该注解\n@Repeatable - 是否可重复注解，jdk1.8引入\n\n注解的生命周期通过@Retention定义注解的生命周期，格式如下：\n@Retention(RetentionPolicy.SOURCE)\n\n其中RetentionPolicy的不同策略对应的生命周期如下：\n\nRetentionPolicy.SOURCE : 仅存在于源代码中，编译阶段会被丢弃，不会包含于class字节码文件中。@Override, @SuppressWarnings都属于这类注解。\nRetentionPolicy.CLASS : 默认策略，在class字节码文件中存在，在类加载的时被丢弃，运行时无法获取到。\nRetentionPolicy.RUNTIME : 始终不会丢弃，可以使用反射获得该注解的信息。自定义的注解最常用的使用方式。\n\n注解的作用目标通过@Target定义注解作用的目标，比如作用于类、属性、或方法等，默认可用于任何地方。格式如下：\n@Target(ElementType.TYPE)\n\n对应ElementType参数值适用范围如下：\n\nElementType.TYPE: 类、接口、注解、enum\nElementType.CONSTRUCTOR: 构造函数\nElementType.FIELD: 成员变量、对象、属性、枚举的常量\nElementType.LOCAL_VARIABLE: 局部变量\nElementType.METHOD: 方法\nElementType.PACKAGE: 包\nElementType.PARAMETER: 参数\nElementType.ANNOTATION_TYPE): 注解\nElementType.TYPE_PARAMETER：类型参数，表示这个注解可以用在 Type的声明式前,jdk1.8引入。\nElementType.TYPE_USE：类型的注解，表示这个注解可以用在所有使用Type的地方（如：泛型，类型转换等），jdk1.8引入。\n\nAOP 实现权限管理拦截器@Aspect@Componentpublic class AuthInterceptor &#123;    @Resource    private UserService userService;    /**     * 执行拦截     *     * @param joinPoint     * @param authCheck     * @return     */    @Around(&quot;@annotation(authCheck)&quot;)    public Object doInterceptor(ProceedingJoinPoint joinPoint, AuthCheck authCheck) throws Throwable &#123;        // 获取注解的 anyRole数组, 将其转换为 List        List&lt;String&gt; anyRole = Arrays.stream(authCheck.anyRole()).filter(StringUtils::isNotBlank).collect(Collectors.toList());        // 获取注解的 mustRole        String mustRole = authCheck.mustRole();        // 获取当前登录用户        RequestAttributes requestAttributes = RequestContextHolder.currentRequestAttributes();        HttpServletRequest request = ((ServletRequestAttributes) requestAttributes).getRequest();        User user = userService.getLoginUser(request);        // 拥有anyRole中任意权限即通过        if (CollectionUtils.isNotEmpty(anyRole)) &#123;            String userRole = user.getUserRole();            if (!anyRole.contains(userRole)) &#123;                throw new BusinessException(ErrorCode.NO_AUTH_ERROR);            &#125;        &#125;        // 必须有所有权限才通过        if (StringUtils.isNotBlank(mustRole)) &#123;            String userRole = user.getUserRole();            if (!mustRole.equals(userRole)) &#123;                throw new BusinessException(ErrorCode.NO_AUTH_ERROR);            &#125;        &#125;        // 通过权限校验，放行        return joinPoint.proceed();    &#125;&#125;\n\n数据库 user 表中，有一个 varChar 类型的 userRole 字段。\n更完善的权限管理方法，应该使用 RBAC 模型，即数据库要有 权限表、角色表、用户表、角色权限表、用户角色表。而鱼皮这里只是简单使用一个字段表示用户角色。\n完美的方案参考：\nspringboot+自定义注解+AOP实现权限控制（一） \nspringboot+自定义注解+AOP实现权限控制（二） \n","categories":["Java"],"tags":["注解","AOP"]},{"title":"项目部署到云服务器后漏洞修复","url":"/2023/05/26/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%88%B0%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%8E%E6%BC%8F%E6%B4%9E%E4%BF%AE%E5%A4%8D/","content":"部署到云服务器之后，发现有5个安全漏洞。\n需要根据修复方案自行修复\n\n\n\nApache Dubbo 漏洞修复将 Apache Dubbo 3.0.9 升级到 3.0.14 及以上版本\n&lt;!-- dubbo --&gt;&lt;dependency&gt;  &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;  &lt;artifactId&gt;dubbo&lt;/artifactId&gt;  &lt;version&gt;3.0.14&lt;/version&gt;&lt;/dependency&gt;\n\nFasterXML jackson-databind 漏洞修复查看 Maven 依赖发现是 Nacos 依赖了 FasterXML jackson-databind 2.13.3。\n需要排除掉 Nacos 中的 jackson-databind 和 jackson-core 2.13.3 依赖，自己引入 2.14.0 以上版本\n&lt;!-- nacos 注册中心 --&gt;&lt;dependency&gt;  &lt;groupId&gt;com.alibaba.nacos&lt;/groupId&gt;  &lt;artifactId&gt;nacos-client&lt;/artifactId&gt;  &lt;version&gt;2.2.0&lt;/version&gt;  &lt;!-- 排除掉nacos依赖的有高危漏洞的2.13jackson，自己引入 2.14.0以上的  --&gt;  &lt;exclusions&gt;    &lt;exclusion&gt;      &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;      &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;    &lt;/exclusion&gt;    &lt;exclusion&gt;      &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;      &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;    &lt;/exclusion&gt;  &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind --&gt;&lt;dependency&gt;  &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;  &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;  &lt;version&gt;2.14.2&lt;/version&gt;&lt;/dependency&gt;\n\nSpring Framework 身份认证绕过漏洞发现是 spring-webmvc-5.3.20 的问题，查看 Maven 依赖，是 spring-boot-starter-web:2.7.0 引入。\n\n直接将项目的 spring boot 版本升级到 2.7.11\n&lt;parent&gt;  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;  &lt;version&gt;2.7.11&lt;/version&gt;  &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;\n\n但升级之后下载不到 mysql-connector-java 的 jar包，因为我们没有指定版本。\n手动指定 mysql-connector-java 的版本即可解决\n&lt;!-- mysql--&gt;&lt;dependency&gt;  &lt;groupId&gt;mysql&lt;/groupId&gt;  &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;  &lt;!--为了修复Spring Framework漏洞 将Spring boot版本升到2.7.11后，  mysql-connector-java 找不到，只能指定版本--&gt;  &lt;version&gt;8.0.31&lt;/version&gt;  &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;\n\n","categories":["项目"],"tags":["项目部署","云服务器"]}]