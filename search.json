[{"title":"Hello World","url":"/2023/05/25/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"自定义注解+AOP实现权限管理","url":"/2023/05/26/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3+AOP%E5%AE%9E%E7%8E%B0%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/","content":"本文使用自定义注解和AOP面向切面编程实现权限管理。\n\n\n\n权限管理注解 @AuthCheck 及 AOP使用方法在需要校验权限的方法（控制器方法）上，加上 @AuthCheck 注解并指定该方法需要什么角色才能访问。\n\n如果没有权限进行操作，就会抛出异常。\n比如：\n\n在方法上使用注解（anyRole)\n\n@AuthCheck(anyRole = &#123;&quot;admin&quot;, &quot;user&quot;&#125;)\n\n最终在AuthInterceptor中，会校验，如果当前登录用户是 anyRole 数组中任一角色，即可访问被这个注解注解的方法。\n\n在方法上使用注解（mustRole)\n\n@AuthCheck(mustRole = &quot;admin&quot;)\n\n最终在AuthInterceptor中，会校验，如果当前登录用户是 mustRole 指定的角色，即可访问被这个注解注解的方法。\n源码学习AuthCheck 注解@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface AuthCheck &#123;    /**     * 有任何一个角色     *     * @return     */    String[] anyRole() default &quot;&quot;;    /**     * 必须有某个角色     *     * @return     */    String mustRole() default &quot;&quot;;&#125;\n\n一篇文章，全面掌握Java自定义注解（Annontation）\n注解的定义\n注解的定义通过@interface表示，所有的注解会自动继承java.lang.Annotation接口,且不能再继承别的类或是接口。\n注解的成员参数只能用public或默认(default) 访问权修饰来进行修饰。\n成员参数只能使用八种基本类型（byte、short、char、int、long、float、double、boolean）和String、Enum、Class、annotations等数据类型，及其数组。\n获取类方法和字段的注解信息，只能通过Java的反射技术来获取 Annotation 对象。\n注解可以没有定义成员，只做标识。\n\n元注解**@Target**和**@Retention**是元注解（注解其他注解的注解）\n\n@Documented – 注解是否将包含在JavaDoc中\n@Retention – 注解的生命周期\n@Target – 注解用于什么地方\n@Inherited – 是否允许子类继承该注解\n@Repeatable - 是否可重复注解，jdk1.8引入\n\n注解的生命周期通过@Retention定义注解的生命周期，格式如下：\n@Retention(RetentionPolicy.SOURCE)\n\n其中RetentionPolicy的不同策略对应的生命周期如下：\n\nRetentionPolicy.SOURCE : 仅存在于源代码中，编译阶段会被丢弃，不会包含于class字节码文件中。@Override, @SuppressWarnings都属于这类注解。\nRetentionPolicy.CLASS : 默认策略，在class字节码文件中存在，在类加载的时被丢弃，运行时无法获取到。\nRetentionPolicy.RUNTIME : 始终不会丢弃，可以使用反射获得该注解的信息。自定义的注解最常用的使用方式。\n\n注解的作用目标通过@Target定义注解作用的目标，比如作用于类、属性、或方法等，默认可用于任何地方。格式如下：\n@Target(ElementType.TYPE)\n\n对应ElementType参数值适用范围如下：\n\nElementType.TYPE: 类、接口、注解、enum\nElementType.CONSTRUCTOR: 构造函数\nElementType.FIELD: 成员变量、对象、属性、枚举的常量\nElementType.LOCAL_VARIABLE: 局部变量\nElementType.METHOD: 方法\nElementType.PACKAGE: 包\nElementType.PARAMETER: 参数\nElementType.ANNOTATION_TYPE): 注解\nElementType.TYPE_PARAMETER：类型参数，表示这个注解可以用在 Type的声明式前,jdk1.8引入。\nElementType.TYPE_USE：类型的注解，表示这个注解可以用在所有使用Type的地方（如：泛型，类型转换等），jdk1.8引入。\n\nAOP 实现权限管理拦截器@Aspect@Componentpublic class AuthInterceptor &#123;    @Resource    private UserService userService;    /**     * 执行拦截     *     * @param joinPoint     * @param authCheck     * @return     */    @Around(&quot;@annotation(authCheck)&quot;)    public Object doInterceptor(ProceedingJoinPoint joinPoint, AuthCheck authCheck) throws Throwable &#123;        // 获取注解的 anyRole数组, 将其转换为 List        List&lt;String&gt; anyRole = Arrays.stream(authCheck.anyRole()).filter(StringUtils::isNotBlank).collect(Collectors.toList());        // 获取注解的 mustRole        String mustRole = authCheck.mustRole();        // 获取当前登录用户        RequestAttributes requestAttributes = RequestContextHolder.currentRequestAttributes();        HttpServletRequest request = ((ServletRequestAttributes) requestAttributes).getRequest();        User user = userService.getLoginUser(request);        // 拥有anyRole中任意权限即通过        if (CollectionUtils.isNotEmpty(anyRole)) &#123;            String userRole = user.getUserRole();            if (!anyRole.contains(userRole)) &#123;                throw new BusinessException(ErrorCode.NO_AUTH_ERROR);            &#125;        &#125;        // 必须有所有权限才通过        if (StringUtils.isNotBlank(mustRole)) &#123;            String userRole = user.getUserRole();            if (!mustRole.equals(userRole)) &#123;                throw new BusinessException(ErrorCode.NO_AUTH_ERROR);            &#125;        &#125;        // 通过权限校验，放行        return joinPoint.proceed();    &#125;&#125;\n\n数据库 user 表中，有一个 varChar 类型的 userRole 字段。\n更完善的权限管理方法，应该使用 RBAC 模型，即数据库要有 权限表、角色表、用户表、角色权限表、用户角色表。而鱼皮这里只是简单使用一个字段表示用户角色。\n完美的方案参考：\nspringboot+自定义注解+AOP实现权限控制（一）\nspringboot+自定义注解+AOP实现权限控制（二）\n","categories":["项目开发"],"tags":["注解","AOP"]}]