[{"title":"自定义注解+AOP实现权限管理","url":"/2023/05/26/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3+AOP%E5%AE%9E%E7%8E%B0%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/","content":"本文使用自定义注解和AOP面向切面编程实现权限管理。\n\n\n\n权限管理注解 @AuthCheck 及 AOP使用方法在需要校验权限的方法（控制器方法）上，加上 @AuthCheck 注解并指定该方法需要什么角色才能访问。\n\n如果没有权限进行操作，就会抛出异常。\n比如：\n\n在方法上使用注解（anyRole)\n\n@AuthCheck(anyRole = &#123;&quot;admin&quot;, &quot;user&quot;&#125;)\n\n最终在AuthInterceptor中，会校验，如果当前登录用户是 anyRole 数组中任一角色，即可访问被这个注解注解的方法。\n\n在方法上使用注解（mustRole)\n\n@AuthCheck(mustRole = &quot;admin&quot;)\n\n最终在AuthInterceptor中，会校验，如果当前登录用户是 mustRole 指定的角色，即可访问被这个注解注解的方法。\n源码学习AuthCheck 注解@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface AuthCheck &#123;    /**     * 有任何一个角色     *     * @return     */    String[] anyRole() default &quot;&quot;;    /**     * 必须有某个角色     *     * @return     */    String mustRole() default &quot;&quot;;&#125;\n\n一篇文章，全面掌握Java自定义注解（Annontation）\n注解的定义\n注解的定义通过@interface表示，所有的注解会自动继承java.lang.Annotation接口,且不能再继承别的类或是接口。\n注解的成员参数只能用public或默认(default) 访问权修饰来进行修饰。\n成员参数只能使用八种基本类型（byte、short、char、int、long、float、double、boolean）和String、Enum、Class、annotations等数据类型，及其数组。\n获取类方法和字段的注解信息，只能通过Java的反射技术来获取 Annotation 对象。\n注解可以没有定义成员，只做标识。\n\n元注解**@Target**和**@Retention**是元注解（注解其他注解的注解）\n\n@Documented – 注解是否将包含在JavaDoc中\n@Retention – 注解的生命周期\n@Target – 注解用于什么地方\n@Inherited – 是否允许子类继承该注解\n@Repeatable - 是否可重复注解，jdk1.8引入\n\n注解的生命周期通过@Retention定义注解的生命周期，格式如下：\n@Retention(RetentionPolicy.SOURCE)\n\n其中RetentionPolicy的不同策略对应的生命周期如下：\n\nRetentionPolicy.SOURCE : 仅存在于源代码中，编译阶段会被丢弃，不会包含于class字节码文件中。@Override, @SuppressWarnings都属于这类注解。\nRetentionPolicy.CLASS : 默认策略，在class字节码文件中存在，在类加载的时被丢弃，运行时无法获取到。\nRetentionPolicy.RUNTIME : 始终不会丢弃，可以使用反射获得该注解的信息。自定义的注解最常用的使用方式。\n\n注解的作用目标通过@Target定义注解作用的目标，比如作用于类、属性、或方法等，默认可用于任何地方。格式如下：\n@Target(ElementType.TYPE)\n\n对应ElementType参数值适用范围如下：\n\nElementType.TYPE: 类、接口、注解、enum\nElementType.CONSTRUCTOR: 构造函数\nElementType.FIELD: 成员变量、对象、属性、枚举的常量\nElementType.LOCAL_VARIABLE: 局部变量\nElementType.METHOD: 方法\nElementType.PACKAGE: 包\nElementType.PARAMETER: 参数\nElementType.ANNOTATION_TYPE): 注解\nElementType.TYPE_PARAMETER：类型参数，表示这个注解可以用在 Type的声明式前,jdk1.8引入。\nElementType.TYPE_USE：类型的注解，表示这个注解可以用在所有使用Type的地方（如：泛型，类型转换等），jdk1.8引入。\n\nAOP 实现权限管理拦截器@Aspect@Componentpublic class AuthInterceptor &#123;    @Resource    private UserService userService;    /**     * 执行拦截     *     * @param joinPoint     * @param authCheck     * @return     */    @Around(&quot;@annotation(authCheck)&quot;)    public Object doInterceptor(ProceedingJoinPoint joinPoint, AuthCheck authCheck) throws Throwable &#123;        // 获取注解的 anyRole数组, 将其转换为 List        List&lt;String&gt; anyRole = Arrays.stream(authCheck.anyRole()).filter(StringUtils::isNotBlank).collect(Collectors.toList());        // 获取注解的 mustRole        String mustRole = authCheck.mustRole();        // 获取当前登录用户        RequestAttributes requestAttributes = RequestContextHolder.currentRequestAttributes();        HttpServletRequest request = ((ServletRequestAttributes) requestAttributes).getRequest();        User user = userService.getLoginUser(request);        // 拥有anyRole中任意权限即通过        if (CollectionUtils.isNotEmpty(anyRole)) &#123;            String userRole = user.getUserRole();            if (!anyRole.contains(userRole)) &#123;                throw new BusinessException(ErrorCode.NO_AUTH_ERROR);            &#125;        &#125;        // 必须有所有权限才通过        if (StringUtils.isNotBlank(mustRole)) &#123;            String userRole = user.getUserRole();            if (!mustRole.equals(userRole)) &#123;                throw new BusinessException(ErrorCode.NO_AUTH_ERROR);            &#125;        &#125;        // 通过权限校验，放行        return joinPoint.proceed();    &#125;&#125;\n\n数据库 user 表中，有一个 varChar 类型的 userRole 字段。\n更完善的权限管理方法，应该使用 RBAC 模型，即数据库要有 权限表、角色表、用户表、角色权限表、用户角色表。而鱼皮这里只是简单使用一个字段表示用户角色。\n完美的方案参考：\nspringboot+自定义注解+AOP实现权限控制（一）\nspringboot+自定义注解+AOP实现权限控制（二）\n","categories":["Java"],"tags":["注解","AOP"]},{"title":"项目部署到云服务器后漏洞修复","url":"/2023/05/26/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%88%B0%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%8E%E6%BC%8F%E6%B4%9E%E4%BF%AE%E5%A4%8D/","content":"部署到云服务器之后，发现有5个安全漏洞。\n需要根据修复方案自行修复\n\n\n\nApache Dubbo 漏洞修复将 Apache Dubbo 3.0.9 升级到 3.0.14 及以上版本\n&lt;!-- dubbo --&gt;&lt;dependency&gt;  &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;  &lt;artifactId&gt;dubbo&lt;/artifactId&gt;  &lt;version&gt;3.0.14&lt;/version&gt;&lt;/dependency&gt;\n\nFasterXML jackson-databind 漏洞修复查看 Maven 依赖发现是 Nacos 依赖了 FasterXML jackson-databind 2.13.3。\n需要排除掉 Nacos 中的 jackson-databind 和 jackson-core 2.13.3 依赖，自己引入 2.14.0 以上版本\n&lt;!-- nacos 注册中心 --&gt;&lt;dependency&gt;  &lt;groupId&gt;com.alibaba.nacos&lt;/groupId&gt;  &lt;artifactId&gt;nacos-client&lt;/artifactId&gt;  &lt;version&gt;2.2.0&lt;/version&gt;  &lt;!-- 排除掉nacos依赖的有高危漏洞的2.13jackson，自己引入 2.14.0以上的  --&gt;  &lt;exclusions&gt;    &lt;exclusion&gt;      &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;      &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;    &lt;/exclusion&gt;    &lt;exclusion&gt;      &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;      &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;    &lt;/exclusion&gt;  &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind --&gt;&lt;dependency&gt;  &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;  &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;  &lt;version&gt;2.14.2&lt;/version&gt;&lt;/dependency&gt;\n\nSpring Framework 身份认证绕过漏洞发现是 spring-webmvc-5.3.20 的问题，查看 Maven 依赖，是 spring-boot-starter-web:2.7.0 引入。\n\n直接将项目的 spring boot 版本升级到 2.7.11\n&lt;parent&gt;  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;  &lt;version&gt;2.7.11&lt;/version&gt;  &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;\n\n但升级之后下载不到 mysql-connector-java 的 jar包，因为我们没有指定版本。\n手动指定 mysql-connector-java 的版本即可解决\n&lt;!-- mysql--&gt;&lt;dependency&gt;  &lt;groupId&gt;mysql&lt;/groupId&gt;  &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;  &lt;!--为了修复Spring Framework漏洞 将Spring boot版本升到2.7.11后，  mysql-connector-java 找不到，只能指定版本--&gt;  &lt;version&gt;8.0.31&lt;/version&gt;  &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;\n\n","categories":["项目"],"tags":["项目部署","云服务器"]}]