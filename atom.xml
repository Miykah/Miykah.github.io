<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Miykah&#39;s Zone</title>
  
  
  <link href="https://miykah.top/atom.xml" rel="self"/>
  
  <link href="https://miykah.top/"/>
  <updated>2023-05-29T07:41:04.972Z</updated>
  <id>https://miykah.top/</id>
  
  <author>
    <name>Miykah</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>接口开放平台项目总结</title>
    <link href="https://miykah.top/2023/05/29/PHM-%E6%8E%A5%E5%8F%A3%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0/"/>
    <id>https://miykah.top/2023/05/29/PHM-%E6%8E%A5%E5%8F%A3%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0/</id>
    <published>2023-05-29T07:40:00.000Z</published>
    <updated>2023-05-29T07:41:04.972Z</updated>
    
    <content type="html"><![CDATA[<h1 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h1><blockquote><p>设想：这是API开放平台，而不是API管理平台。面试官可能会说，可以使用已有的如Swagger这样的API管理，为什么还要开发？<br>API开放平台和管理平台不一样。开放平台，管理员发布接口，用户可以申请开通接口，开通之后接口调用次数可以有限制。<br>怎么考虑结合大项目讲？<br>大项目的健康管理平台会给很多企业使用，大项目可以做二次开发出前端界面，需要调用一些接口。企业人员可以自己进行二次开发，我们（学生）后续也可以提供一些接口，供企业二次开发使用。所以可以使用API开放平台进行接口的发布，客户（企业）开通接口权限。</p></blockquote><p>大型旋转机组健康管理系统软件衍生项目，为业务人员二次开发提供接口的开放平台。管理员负责提供接口并发布上线接口，可视化统计接口调用情况。业务人员（用户）可以申请接口调用权限后，进行接口在线测试，在用户进行二次开发时，通过引入客户端SDK可以方便地调用接口。</p><h1 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h1><ul><li>API接入</li><li>接口在线测试</li><li>防止攻击（安全性、ak &#x2F; sk鉴权）</li><li>限制调用次数</li><li>统计调用次数</li><li>流量保护</li><li>提供SDK便于业务人员调用接口</li></ul><h1 id="主要技术选型"><a href="#主要技术选型" class="headerlink" title="主要技术选型"></a>主要技术选型</h1><ul><li>后端<ul><li>Spring Boot</li><li>MySQL</li><li>MyBatis-Plus</li><li>API 签名认证</li><li>Spring Cloud Gateway</li><li>Dubbo</li><li>Nacos</li><li>Spring Boot Starter</li></ul></li><li>前端<ul><li>React</li><li>Ant Design Pro</li></ul></li></ul><h1 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h1><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.nlark.com/yuque/0/2023/jpeg/35923527/1684760655076-b1a34046-4dec-4faa-b662-51c3550ed56c.jpeg"                                     ></p><h1 id="后端项目划分"><a href="#后端项目划分" class="headerlink" title="后端项目划分"></a>后端项目划分</h1><ul><li>phmapi-backend：7529端口，后端主项目</li><li>phmapi-gateway：8090端口，网关</li><li>phmapi-interface：8123端口，接口提供服务</li><li>phmapi-client-sdk：客户端SDK</li><li>phmapi-comon：公共模块</li></ul><h1 id="简历写法"><a href="#简历写法" class="headerlink" title="简历写法"></a>简历写法</h1><p><strong>项目名称：</strong>PHM在线接口开放平台<br><strong>上线地址：</strong><a class="link"   href="http://139.155.144.134:8000/" >http://139.155.144.134:8000/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br><strong>项目介绍：</strong>大型旋转机组健康管理系统软件衍生项目，为业务人员二次开发提供接口的开放平台。管理员负责提供接口并发布上线接口，可视化统计接口调用情况。业务人员（用户）可以申请接口调用权限后，进行接口在线测试，在用户进行二次开发时，通过引入客户端SDK可以方便地调用接口。<br><strong>技术选型：</strong>Spring Boot + Spring Cloud Gateway + Dubbo + Nacos + MySQL + React<br><strong>主要工作：</strong></p><ol><li>根据项目业务需要，将项目拆分为web主项目、接口提供项目、公共模块、网关和客户端SDK；</li><li>自定义注解，结合 AOP 实现对后端方法的权限控制；同时使用 AOP 实现全局请求响应拦截器用于记录日志；</li><li>使用签名认证算法，为业务人员分配 accessKey 以及 secretKey 用于鉴权，防止接口被恶意调用，保证接口服务的安全性；</li><li>选用 Spring Cloud Gateway 作为项目的网关，实现路由转发及流量染色以保护接口服务，并使用全局过滤器集中处理用户调用接口时的签名校验、接口调用次数统计及限制等业务逻辑，提高安全性的同时、便于系统开发维护；</li><li>为了减少重复代码、提高代码的可重用性，将模型层以及部分业务层接口抽象为公共模块，满足主项目和网关的业务需求，并使用 Dubbo 框架实现这两个子项目间的远程调用；</li><li>基于 Spring Boot Starter 开发接口调用的SDK，业务人员可以通过引入 SDK 很方便地调用平台提供的开放接口，提高用户的开发体验。</li></ol><h1 id="项目遇到的问题"><a href="#项目遇到的问题" class="headerlink" title="项目遇到的问题"></a>项目遇到的问题</h1><h2 id="BUG解决"><a href="#BUG解决" class="headerlink" title="BUG解决"></a>BUG解决</h2><h3 id="数据源配置问题"><a href="#数据源配置问题" class="headerlink" title="数据源配置问题"></a>数据源配置问题</h3><blockquote><p>问题描述：抽取公共模块 <code>phmapi-common</code>时，common中引入了数据库相关的依赖（如MyBatis-plus和MyBatis），然后 <code>phmapi-gateway</code>项目引入了 <code>phmapi-common</code>, 但是 <code>phmapi-gateway</code> 并未在配置文件yml中配置数据源，application 启动时报错。</p></blockquote><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Description:</span><br><span class="line"></span><br><span class="line">Failed to configure a DataSource: <span class="string">&#x27;url&#x27;</span> attribute is not specified and no embedded datasource could be configured.</span><br><span class="line"></span><br><span class="line">Reason: Failed to determine a suitable driver class</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Action:</span><br><span class="line"></span><br><span class="line">Consider the following:</span><br><span class="line">If you want an embedded database (H2, HSQL or Derby), please put it on the classpath.</span><br><span class="line">If you have database settings to be loaded from a particular profile you may need to activate it (no profiles are currently active).</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p><strong>解决办法</strong><br>在 <code>phmapi-gateway</code> 的启动类中排除数据源相关的类。</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication(exclude = &#123;</span></span><br><span class="line"><span class="meta">    DataSourceAutoConfiguration.class,</span></span><br><span class="line"><span class="meta">    DataSourceTransactionManagerAutoConfiguration.class,</span></span><br><span class="line"><span class="meta">    HibernateJpaAutoConfiguration.class&#125;)</span></span><br><span class="line"><span class="meta">@EnableDubbo</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PhmapiGatewayApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(PhmapiGatewayApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="点击调用接口，接口调用次数减了两次"><a href="#点击调用接口，接口调用次数减了两次" class="headerlink" title="点击调用接口，接口调用次数减了两次"></a>点击调用接口，接口调用次数减了两次</h3><blockquote><p>问题描述：对某个接口（getAllThings）点击测试调用的时候，调用统计中，调用次数加了两次，剩余次数减了两次。点击一次，次数却-2或+2，其余接口没有这个问题。</p></blockquote><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.nlark.com/yuque/0/2023/png/35923527/1684547540699-a48854eb-3d3b-4bb4-acfc-a0254183cb66.png#averageHue=%23fafafa&clientId=u6d9db1fc-ed8f-4&from=paste&height=516&id=uc78e05fe&originHeight=1032&originWidth=1391&originalType=binary&ratio=1.100000023841858&rotation=0&showTitle=false&size=88472&status=done&style=none&taskId=u97eeafe2-d365-4eb6-a1c7-14141c90764&title=&width=696"                      alt="image.png"                ><br>处理接口统计次数更新的逻辑在 <code>phmapi-gateway</code>项目中，在过滤器中处理。<br>DeBug发现更新次数的逻辑执行了两次。<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.nlark.com/yuque/0/2023/png/35923527/1684547668578-46cc5d3b-7922-4153-86f7-0efa4f062da1.png#averageHue=%232d2c2b&clientId=u6d9db1fc-ed8f-4&from=paste&id=ufec5399d&originHeight=378&originWidth=909&originalType=binary&ratio=1.100000023841858&rotation=0&showTitle=false&size=45180&status=done&style=none&taskId=uf2f8fdcd-12a7-4c47-8de1-27a39293775&title="                      alt="image.png"                ><br><strong>发现打印日志中，接口返回的Response分了两次打印，第一次没打印完，第二次接着打印。</strong><br>**猜测可能是由于字符串的缓冲区不够，需要分两次或多次才能将response放到 **<code>**dataBuffer**</code>**？导致分了两次打印，导致执行了两次 **<code>**invokeCount**</code><strong>这个方法。</strong></p><blockquote><p><strong>有时候还会执行三次</strong></p></blockquote><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.nlark.com/yuque/0/2023/png/35923527/1684548141669-c8e3c969-5f1d-4535-850e-6e2ffe573c10.png#averageHue=%232d2c2c&clientId=u6d9db1fc-ed8f-4&from=paste&height=592&id=u41384d3f&originHeight=651&originWidth=1281&originalType=binary&ratio=1.100000023841858&rotation=0&showTitle=false&size=144125&status=done&style=none&taskId=uf311c62e-08fe-4fd8-87eb-c32389d9e47&title=&width=1164.545429304612"                      alt="image.png"                ><br><strong>解决办法：</strong></p><ul><li><strong>方法一：偷懒的办法，将逻辑提前，不放在处理日志里面</strong></li></ul><p>之所以将更新调用次数的逻辑写到记录日志的时候，是因为这个时候保证接口已经调用完成。<br>这里为了解决这个问题，偷个懒，把更新次数的逻辑提前。<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.nlark.com/yuque/0/2023/png/35923527/1684548485733-06920ab4-5f1f-41bb-aea7-152a4f200ae9.png#averageHue=%232d2c2c&clientId=u6d9db1fc-ed8f-4&from=paste&id=ub2f64d4c&originHeight=370&originWidth=742&originalType=binary&ratio=1.100000023841858&rotation=0&showTitle=false&size=47634&status=done&style=none&taskId=uc0cae24f-8df5-485e-bcf7-1cebf454dfc&title="                      alt="image.png"                ></p><ul><li><strong>方法二：不改变原有逻辑</strong></li></ul><p>**使用一个 count 记录 **<code>**invokeCount**</code>**方法的调用次数，只允许 **<code>**invokeCount**</code><strong>调用一次。</strong><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.nlark.com/yuque/0/2023/png/35923527/1684554712935-97d7643f-7f86-41fa-82c4-31d9f0c57f48.png#averageHue=%232c2c2b&clientId=u8e5aef47-feb7-4&from=paste&height=582&id=ue99bb8c6&originHeight=640&originWidth=1142&originalType=binary&ratio=1.100000023841858&rotation=0&showTitle=false&size=91234&status=done&style=none&taskId=u67559acd-8a22-4d24-b935-123da300177&title=&width=1038.1817956798338"                      alt="image.png"                ></p><h3 id="解决绕过网关请求接口问题"><a href="#解决绕过网关请求接口问题" class="headerlink" title="解决绕过网关请求接口问题"></a>解决绕过网关请求接口问题</h3><p><strong>问题描述：</strong><br>用户请求接口的地址必须是经过网关的。比如 <a class="link"   href="http://172.28.9.61:8090/api/gas-turbine/things/" >http://172.28.9.61:8090/api/gas-turbine/things/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br><code>8090</code>就是项目的网管端口，然后经过网关鉴权后，会路由到项目提供接口的服务<a class="link"   href="http://172.28.9.61:8123/api/gas-turbine/things/" >http://172.28.9.61:8123/api/gas-turbine/things/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。<br>**需要保证用户请求都必须经过网关，但如果用户得知了接口服务的端口 **<code>**8123**</code><strong>，就可能会绕过网关直接请求到接口，也就绕过了鉴权、计数等一系列流程。</strong></p><p><strong>解决办法：</strong><br>利用网关的 <code>filters</code>做一个<strong>流量染色</strong>。给转发到接口服务的请求加上请求头标识这个请求是来自网关，接口服务取出请求头进行判断。</p><ul><li><p>对于 <code>phmapi-gateway</code>项目，在 <code>application.yml</code>中添加配置：</p><div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">api_route</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://172.28.9.61:8123</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/api/**</span></span><br><span class="line">          <span class="attr">filters:</span></span><br><span class="line">            <span class="string">//</span> <span class="string">添加请求头(</span> <span class="string">Request-source</span> <span class="string">=</span> <span class="string">gateway</span> <span class="string">)</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">AddRequestHeader=Request-source,</span> <span class="string">gateway</span></span><br></pre></td></tr></table></figure></div></li><li><p>对于接口服务 <code>phmapi-interface</code>，取出请求头判断是否来自网关，如果不是来自网关则返回空。</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/things&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getAllThing</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">    <span class="comment">//校验请求是否来自网关</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isFromGateway</span> <span class="operator">=</span> authUtil.auth(request);</span><br><span class="line">    <span class="keyword">if</span> (!isFromGateway) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用接口</span></span><br><span class="line">        <span class="type">HttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> HttpRequest.get(<span class="string">&quot;http://202.202.3.68:52310/gateway/api/v2/thing-operator/namespaces/cqu-edu/projects/gas-turbine-engine-phm/things&quot;</span>)</span><br><span class="line">        .execute();</span><br><span class="line">        <span class="keyword">return</span> response.body();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">REQUEST_SOURCE_HEADER</span> <span class="operator">=</span> <span class="string">&quot;gateway&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">auth</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">        <span class="comment">// 取出请求头判断是否等于 &quot;gateway&quot;</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">header</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;Request-source&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> header != <span class="literal">null</span> &amp;&amp; header.equals(REQUEST_SOURCE_HEADER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ul><h3 id="前端BUG：用户头像加载不出来，导致弹不出退出登录"><a href="#前端BUG：用户头像加载不出来，导致弹不出退出登录" class="headerlink" title="前端BUG：用户头像加载不出来，导致弹不出退出登录"></a>前端BUG：用户头像加载不出来，导致弹不出退出登录</h3><p><strong>问题描述：</strong><br>用户头像一直转圈，导致弹不出退出登录按钮，无法退出登录。<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.nlark.com/yuque/0/2023/png/35923527/1684805821617-0d5d4be0-bf58-4365-9282-65a51b13d9d7.png#averageHue=%23f4f4f4&clientId=u3ad31785-20e4-4&from=paste&height=217&id=u8a99bc9b&originHeight=299&originWidth=569&originalType=binary&ratio=1.375&rotation=0&showTitle=false&size=6244&status=done&style=none&taskId=u7f0c36f0-d8a0-4790-8f28-4f401282fb6&title=&width=413.8181818181818"                      alt="image.png"                ><br><strong>解决办法：</strong><br>找了一些解决办法<br>（1）用户没有userName（但我的有）（2）用户头像userAvatar属性没有值，我给用户的avatar图片地址后仍然不行。<br>最后找到问题原因：<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.nlark.com/yuque/0/2023/png/35923527/1684806148066-0d1d39f4-c1fe-4acc-82d1-1a598c8da821.png#averageHue=%232d2c2c&clientId=u3ad31785-20e4-4&from=paste&height=180&id=u2d72d4b2&originHeight=247&originWidth=586&originalType=binary&ratio=1.375&rotation=0&showTitle=false&size=26256&status=done&style=none&taskId=uf4beb453-16f5-4c6a-ae6f-916f0ac3a49&title=&width=426.1818181818182"                      alt="image.png"                ><br><code>src/components/RightContent/AvaratDropdown.tsx</code> 文件中，登录用户使用的是 Ant Design Pro 自己定义的 <code>currentUser</code> ，而我们应该使用 <code>loginUser</code>，将该文件中的 <code>currentUser</code> 全部替换成 <code>loginUser</code> 后解决问题。</p><h3 id="前端BUG：点击退出登录后，不跳转到登录页面"><a href="#前端BUG：点击退出登录后，不跳转到登录页面" class="headerlink" title="前端BUG：点击退出登录后，不跳转到登录页面"></a>前端BUG：点击退出登录后，不跳转到登录页面</h3><p><strong>问题描述：</strong><br>在解决上一个BUG后，可以点击退出登录，退出登录功能也没问题，但是不会自动跳转到登录页面，而是仍然停留在当前页面（虽然这个时候点击任何东西后，会检测到没有登录，再跳转到登录页面）。<br>但我需要一点击退出登录，就自动跳转到登录页面。<br><strong>解决办法：</strong><br>问题所在仍然是<code>src/components/RightContent/AvaratDropdown.tsx</code> 文件，点击退出登录按钮的逻辑问题。<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.nlark.com/yuque/0/2023/png/35923527/1684806555660-1b005758-ba7b-4c87-a01e-6458f94660ea.png#averageHue=%232d2c2b&clientId=u3ad31785-20e4-4&from=paste&height=319&id=uc0a6c722&originHeight=438&originWidth=742&originalType=binary&ratio=1.375&rotation=0&showTitle=false&size=87050&status=done&style=none&taskId=ub6ada2e9-5527-4d47-a3a2-fab67b93ea4&title=&width=539.6363636363636"                      alt="image.png"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.nlark.com/yuque/0/2023/png/35923527/1684806561588-1705aeb8-cca7-4fef-9668-f9df5546999d.png#averageHue=%232e2c2b&clientId=u3ad31785-20e4-4&from=paste&height=304&id=udd13a1d0&originHeight=418&originWidth=610&originalType=binary&ratio=1.375&rotation=0&showTitle=false&size=63231&status=done&style=none&taskId=uf54c5312-2ee2-416f-a448-7c4d5695219&title=&width=443.6363636363636"                      alt="image.png"                ></p><h2 id="漏洞解决"><a href="#漏洞解决" class="headerlink" title="漏洞解决"></a>漏洞解决</h2><blockquote><p>部署到云服务器之后，发现有5个安全漏洞。<br>需要根据修复方案自行修复</p></blockquote><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.nlark.com/yuque/0/2023/png/35923527/1684895015975-9270d774-97b9-492a-a143-6bfdddcccf0a.png#averageHue=%23fdfbfa&clientId=uccde73ae-a5f5-4&from=paste&height=634&id=u3c7b2754&originHeight=697&originWidth=1098&originalType=binary&ratio=1.100000023841858&rotation=0&showTitle=false&size=61498&status=done&style=none&taskId=ufdfbe8cb-7055-4f38-b303-7169edd8a3d&title=&width=998.1817965468103"                      alt="image.png"                ></p><h3 id="Apache-Dubbo-漏洞修复"><a href="#Apache-Dubbo-漏洞修复" class="headerlink" title="Apache Dubbo 漏洞修复"></a>Apache Dubbo 漏洞修复</h3><p>将 Apache Dubbo 3.0.9 升级到 3.0.14 及以上版本</p><div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- dubbo --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.dubbo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.14<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div><h3 id="FasterXML-jackson-databind-漏洞修复"><a href="#FasterXML-jackson-databind-漏洞修复" class="headerlink" title="FasterXML jackson-databind 漏洞修复"></a>FasterXML jackson-databind 漏洞修复</h3><p>查看 Maven 依赖发现是 Nacos 依赖了 FasterXML jackson-databind 2.13.3。<br>需要排除掉 Nacos 中的 jackson-databind 和 jackson-core 2.13.3 依赖，自己引入 2.14.0 以上版本</p><div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- nacos 注册中心 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.nacos<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>nacos-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 排除掉nacos依赖的有高危漏洞的2.13jackson，自己引入 2.14.0以上的  --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.14.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div><h3 id="Spring-Framework-身份认证绕过漏洞"><a href="#Spring-Framework-身份认证绕过漏洞" class="headerlink" title="Spring Framework 身份认证绕过漏洞"></a><strong>Spring Framework 身份认证绕过漏洞</strong></h3><p>发现是 spring-webmvc-5.3.20 的问题，查看 Maven 依赖，是 spring-boot-starter-web:2.7.0 引入。<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.nlark.com/yuque/0/2023/png/35923527/1684896216208-d24e73ac-d69b-4c14-95a9-92921d12187f.png#averageHue=%23374046&clientId=uccde73ae-a5f5-4&from=paste&height=105&id=u6f945738&originHeight=116&originWidth=544&originalType=binary&ratio=1.100000023841858&rotation=0&showTitle=false&size=13712&status=done&style=none&taskId=udb0aaf3c-34e2-40aa-979e-dd93fac924a&title=&width=494.5454438264707"                      alt="image.png"                ><br>直接将项目的 spring boot 版本升级到 2.7.11</p><div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure></div><p>但升级之后下载不到 mysql-connector-java 的 jar包，因为我们没有指定版本。<br>手动指定 mysql-connector-java 的版本即可解决</p><div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- mysql--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--为了修复Spring Framework漏洞 将Spring boot版本升到2.7.11后，</span></span><br><span class="line"><span class="comment">  mysql-connector-java 找不到，只能指定版本--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.31<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div><h1 id="项目优化"><a href="#项目优化" class="headerlink" title="项目优化"></a>项目优化</h1><h2 id="网关返回自定义值"><a href="#网关返回自定义值" class="headerlink" title="网关返回自定义值"></a>网关返回自定义值</h2><p>原本网关鉴权等流程如果没有通过，会进入到网关的 <code>handleNoAuth</code> 等方法。</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Mono&lt;Void&gt; <span class="title function_">handleNoAuth</span><span class="params">(ServerHttpResponse response)</span> &#123; </span><br><span class="line">    response.setStatusCode(HttpStatus.FORBIDDEN); </span><br><span class="line">    <span class="keyword">return</span> response.setComplete(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>如果这样的话最终返回到 backend 时，很难判断到底有没有请求成功（因为是根据返回的字符串是否为空判断）。所以如果请求失败，返回一个错误页面（字符串不为空），也会弹出请求成功的提示框。<br>为了解决这个问题，在网关自定义返回值 JSONObject，同时各个接口也统一返回值为 JSONObject。<br>如果请求成功，返回的是接口的 JSONObject，如果遇到无权限等情况，网关也会返回 JSONObject。<br>后端再根据响应的字符串body，反序列化成 JSONObject，判断自定义的 JSONObject 的 code 字段是否正常，来判断是否请求成功。</p><ul><li><strong>网关层：</strong></li></ul><p>参考：<a class="link"   href="https://blog.csdn.net/qq_37312208/article/details/119996202" >https://blog.csdn.net/qq_37312208&#x2F;article&#x2F;details&#x2F;119996202 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br><a class="link"   href="https://www.cnblogs.com/wangbin96/p/12531935.html" >https://www.cnblogs.com/wangbin96/p/12531935.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Mono&lt;Void&gt; <span class="title function_">handleNoAuth</span><span class="params">(ServerHttpResponse response)</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 Hutool 工具类，创建一个 JSONObject</span></span><br><span class="line">    <span class="type">JSONObject</span> <span class="variable">result</span> <span class="operator">=</span> JSONUtil.createObj();</span><br><span class="line">    result.set(<span class="string">&quot;code&quot;</span>, -<span class="number">1</span>);</span><br><span class="line">    result.set(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;无权限！&quot;</span>);</span><br><span class="line">    <span class="type">byte</span>[] bytes = JSONUtil.toJsonStr(result).getBytes(StandardCharsets.UTF_8);</span><br><span class="line">    response.getHeaders().setContentType(MediaType.APPLICATION_JSON);</span><br><span class="line">    response.setStatusCode(HttpStatus.UNAUTHORIZED);</span><br><span class="line">    <span class="type">DataBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> response.bufferFactory().wrap(bytes);</span><br><span class="line">    <span class="keyword">return</span> response.writeWith(Mono.just(buffer));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li><p><strong>接口服务：</strong></p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/things&quot;)</span></span><br><span class="line"><span class="keyword">public</span> JSONObject <span class="title function_">getAllThing</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">    <span class="comment">//校验请求是否来自网关</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isFromGateway</span> <span class="operator">=</span> authUtil.auth(request);</span><br><span class="line">    <span class="keyword">if</span> (!isFromGateway) &#123;</span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">jsonObject</span> <span class="operator">=</span> JSONUtil.createObj();</span><br><span class="line">        jsonObject.set(<span class="string">&quot;code&quot;</span>, -<span class="number">1</span>);</span><br><span class="line">        jsonObject.set(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;无权限！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> jsonObject;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用接口</span></span><br><span class="line">        <span class="type">HttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> HttpRequest.get(<span class="string">&quot;http://202.202.3.68:52310/gateway/api/v2/thing-operator/namespaces/cqu-edu/projects/gas-turbine-engine-phm/things&quot;</span>)</span><br><span class="line">        .execute();</span><br><span class="line">        <span class="keyword">return</span> JSONUtil.parseObj(response.body(), <span class="literal">true</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">jsonObject</span> <span class="operator">=</span> JSONUtil.createObj();</span><br><span class="line">        jsonObject.set(<span class="string">&quot;code&quot;</span>, -<span class="number">1</span>);</span><br><span class="line">        jsonObject.set(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;系统错误！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> jsonObject;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li><li><p><strong>SDK：</strong></p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> JSONObject <span class="title function_">invokeByURL</span><span class="params">(String url, String params, String method)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        HttpResponse response;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;POST&quot;</span>.equals(method)) &#123;</span><br><span class="line">            response = HttpRequest.post(url)</span><br><span class="line">                                    .addHeaders(getHeaderMap(params))</span><br><span class="line">                                    .body(params).execute();</span><br><span class="line">            <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> response.body();</span><br><span class="line">            <span class="keyword">return</span> JSONUtil.parseObj(res);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;GET&quot;</span>.equals(method)) &#123;</span><br><span class="line">            response = HttpRequest.get(url)</span><br><span class="line">                                    .addHeaders(getHeaderMap(params))</span><br><span class="line">                                    .execute();</span><br><span class="line">            <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> response.body();</span><br><span class="line">            <span class="keyword">return</span> JSONUtil.parseObj(res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> JSONUtil.createObj().set(<span class="string">&quot;code&quot;</span>, -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li><li><p><code>** backend **</code>**的 **<code>**invoke **</code><strong>方法：</strong></p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/invoke&quot;)</span></span><br><span class="line"><span class="keyword">public</span> BaseResponse&lt;Object&gt; <span class="title function_">invokeInterfaceInfo</span><span class="params">(<span class="meta">@RequestBody</span> InterfaceInfoInvokeRequest interfaceInfoInvokeRequest,</span></span><br><span class="line"><span class="params">                                                HttpServletRequest request)</span> &#123;</span><br><span class="line">    <span class="comment">// 省略。。。。。。。。。。。。。。。。。。。。。</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">PhmApiClient</span> <span class="variable">tempClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PhmApiClient</span>(accessKey, secretKey);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据url调用相应的方法</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// SDK 返回的是JSONObject </span></span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">jsonObject</span> <span class="operator">=</span> tempClient.invokeByURL(interfaceInfo.getUrl(), userRequestParams, interfaceInfo.getMethod());</span><br><span class="line">        <span class="comment">// 如果 code == -1 说明出了问题 抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="type">int</span>)jsonObject.get(<span class="string">&quot;code&quot;</span>) == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(ErrorCode.NO_AUTH_ERROR, (String) jsonObject.get(<span class="string">&quot;message&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回的不再是字符串，而是JSONObject，可以方便渲染json</span></span><br><span class="line">        <span class="keyword">return</span> ResultUtils.success(jsonObject);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(ErrorCode.SYSTEM_ERROR, e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ul><h2 id="前端对-JSON-进行渲染"><a href="#前端对-JSON-进行渲染" class="headerlink" title="前端对 JSON 进行渲染"></a>前端对 JSON 进行渲染</h2><p>前端界面请求后的结果是字符串，展示出来不友好。<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.nlark.com/yuque/0/2023/png/35923527/1684987137712-62248f5d-8e4d-4326-be29-e762f74e84e4.png#averageHue=%23f4f4f4&clientId=u1bbb41f4-3f51-4&from=paste&height=295&id=u3dd841e8&originHeight=405&originWidth=2114&originalType=binary&ratio=1.375&rotation=0&showTitle=false&size=87776&status=done&style=none&taskId=u489927ce-db26-4133-a723-d5bb08aeb3b&title=&width=1537.4545454545455"                      alt="image.png"                ><br><strong>优化方案：</strong><br><strong>前提条件：在上一个优化中，我们已经统一返回结果为 JSONObject，因此可以找到一个前端组件，直接渲染 JSONObject。找到了 <strong><code>**react-json-view**</code></strong> 组件。</strong><br><a class="link"   href="https://www.cnblogs.com/aleifighting/p/15100210.html" >react-json-view的使用 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>在前端项目引入该库</p><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install --save react-json-view --legacy-peer-deps</span><br><span class="line">// 要加上--legacy-peer-deps 否则可能报错</span><br></pre></td></tr></table></figure></div><p>然后在展示结果的地方，更改代码</p><div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Card</span> <span class="attr">hidden</span>=<span class="string">&#123;!invokeRes&#125;</span> <span class="attr">title</span>=<span class="string">&quot;结果&quot;</span> &gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Spin</span> <span class="attr">spinning</span>=<span class="string">&#123;invokeLoading&#125;/</span>&gt;</span></span><br><span class="line">    &#123;invokeRes ? <span class="tag">&lt;<span class="name">ReactJson</span> <span class="attr">theme</span>=<span class="string">&quot;rjv-default&quot;</span> <span class="attr">displayDataTypes</span>=<span class="string">&#123;false&#125;</span> <span class="attr">src</span>=<span class="string">&#123;invokeRes&#125;/</span>&gt;</span> : <span class="tag">&lt;&gt;</span>无<span class="tag">&lt;/&gt;</span>&#125;</span><br><span class="line">    &#123;/*&#123;invokeRes&#125;*/&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">Card</span>&gt;</span></span><br></pre></td></tr></table></figure></div><p>渲染后的效果对于JSON的显示更加友好：<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.nlark.com/yuque/0/2023/png/35923527/1684987776986-35a72c54-74c1-49f3-abc0-b35047127d67.png#averageHue=%23fefdfc&clientId=u1bbb41f4-3f51-4&from=paste&height=289&id=uc226ac2d&originHeight=578&originWidth=846&originalType=binary&ratio=1.375&rotation=0&showTitle=false&size=59682&status=done&style=none&taskId=u5ff4f63e-bb0d-4a5c-9cfe-b976253cc5b&title=&width=423"                      alt="image.png"                ></p><h1 id="项目部署流程"><a href="#项目部署流程" class="headerlink" title="项目部署流程"></a>项目部署流程</h1><blockquote><p>新买了一个云服务器，部署这个项目</p></blockquote><h2 id="安装-MySQL"><a href="#安装-MySQL" class="headerlink" title="安装 MySQL"></a>安装 MySQL</h2><p>为了方便起见，直接在宝塔面板安装 MySQL，版本为8.0.<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.nlark.com/yuque/0/2023/png/35923527/1684831300245-3f2603e9-59d3-455f-b720-ad892014400b.png#averageHue=%23fcfbfa&clientId=u0918ef5a-1737-4&from=paste&height=34&id=u522df07b&originHeight=47&originWidth=252&originalType=binary&ratio=1.375&rotation=0&showTitle=false&size=2324&status=done&style=none&taskId=u6a9499b0-28ed-4036-b33c-3be478ccf43&title=&width=183.27272727272728"                      alt="image.png"                ><br>安装完成后在 宝塔面板-安全 防火墙中放行3306端口，同时在腾讯云服务器的防火墙中也放行3306。<br>在宝塔面板中修改数据库 root 密码。</p><p><strong>在电脑远程测试连接云服务器的 MySQL，显示连接失败</strong><br>在服务器本机登录 MySQL，执行以下操作：</p><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">use mysql;</span></span><br><span class="line">Database changed</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash"><span class="keyword">select</span> user,host from user;</span></span><br><span class="line">+------------------+-----------+</span><br><span class="line">| user             | host      |</span><br><span class="line">+------------------+-----------+</span><br><span class="line">| mysql.infoschema | localhost |</span><br><span class="line">| mysql.session    | localhost |</span><br><span class="line">| mysql.sys        | localhost |</span><br><span class="line">| root             | localhost |</span><br><span class="line">+------------------+-----------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">update user <span class="built_in">set</span> host = <span class="string">&#x27;%&#x27;</span> <span class="built_in">where</span> user=<span class="string">&#x27;root&#x27;</span>;</span></span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash"><span class="keyword">select</span> user,host from user;</span></span><br><span class="line">+------------------+-----------+</span><br><span class="line">| user             | host      |</span><br><span class="line">+------------------+-----------+</span><br><span class="line">| root             | %         |</span><br><span class="line">| mysql.infoschema | localhost |</span><br><span class="line">| mysql.session    | localhost |</span><br><span class="line">| mysql.sys        | localhost |</span><br><span class="line">+------------------+-----------+</span><br><span class="line">4 rows in set (0.01 sec)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">flush privileges;</span></span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure></div><p>再次远程连接即可成功！<br>将本机的 <code>phmapi</code> 数据库复制到云服务器的数据库。</p><h2 id="安装-Redis"><a href="#安装-Redis" class="headerlink" title="安装 Redis"></a>安装 Redis</h2><p>在宝塔面板中安装 Redis<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.nlark.com/yuque/0/2023/png/35923527/1684831627163-7f32716a-2c9a-4474-a21c-6f0adade7ef2.png#averageHue=%23f9f4f4&clientId=u0918ef5a-1737-4&from=paste&height=31&id=ueec57683&originHeight=42&originWidth=220&originalType=binary&ratio=1.375&rotation=0&showTitle=false&size=2396&status=done&style=none&taskId=u36c1ed60-051c-4e9a-861e-ad5aed5ae7f&title=&width=160"                      alt="image.png"                ><br>设置<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.nlark.com/yuque/0/2023/png/35923527/1684831672371-bea2bb6f-5336-49ea-a912-a81c6e2cafbb.png#averageHue=%23f8f8f8&clientId=u0918ef5a-1737-4&from=paste&height=292&id=uc2a4c6a4&originHeight=401&originWidth=669&originalType=binary&ratio=1.375&rotation=0&showTitle=false&size=32086&status=done&style=none&taskId=u13708d9c-e0d7-4b6f-933b-155c441e61f&title=&width=486.54545454545456"                      alt="image.png"                ><br>同时宝塔和云服务器防火墙记得放行 6379 端口。</p><h2 id="安装-JDK1-8"><a href="#安装-JDK1-8" class="headerlink" title="安装 JDK1.8"></a>安装 JDK1.8</h2><ol><li><p>在 <code>/opt</code> 目录下新建两个文件夹，用于存放安装源文件和安装后的软件。</p><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@miykah ~]# cd /opt/</span><br><span class="line">[root@miykah opt]# mkdir downfile</span><br><span class="line">[root@miykah opt]# mkdir software</span><br></pre></td></tr></table></figure></div></li><li><p>下载 JDK 压缩包</p></li></ol><p><a class="link"   href="https://www.oracle.com/java/technologies/downloads/#java8" >https://www.oracle.com/java/technologies/downloads/#java8 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.nlark.com/yuque/0/2023/png/35923527/1684832193386-b9d298cf-01e6-42aa-87bd-639f220e6419.png#averageHue=%23f9f8f8&clientId=u0918ef5a-1737-4&from=paste&height=543&id=u515b68ea&originHeight=747&originWidth=1654&originalType=binary&ratio=1.375&rotation=0&showTitle=false&size=101543&status=done&style=none&taskId=uc5059db4-0ed7-47a6-aabb-e02a49de861&title=&width=1202.909090909091"                      alt="image.png"                ><br>放到服务器的 <code>/opt/downfile</code>文件夹</p><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@miykah downfile]# ll</span><br><span class="line">总用量 135512</span><br><span class="line">-rw-r--r-- 1 root root 138762230 5月  23 16:59 jdk-8u361-linux-x64.tar.gz</span><br></pre></td></tr></table></figure></div><ol start="3"><li><p>解压 JDK 压缩包到<code>/opt/software</code> 目录</p><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@miykah downfile]# tar -zxvf jdk-8u361-linux-x64.tar.gz -C /opt/software</span><br></pre></td></tr></table></figure></div></li><li><p>配置环境变量</p></li></ol><p>Linux环境变量配置都在：&#x2F;etc&#x2F;profile文件中<br>VIM命令编辑文件（建议编辑前复制一份源文件作为备份）</p><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 #####vim打开编辑文件</span><br><span class="line">2 [root@miykah ~]# vim /etc/profile</span><br><span class="line">3  ………略………</span><br><span class="line">4 按键 i 进入插入编辑模式。</span><br></pre></td></tr></table></figure></div><p>编辑模式下，在结尾或开头添加如下：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 export JAVA_HOME=/opt/software/jdk1.8.0_361</span><br><span class="line">2 export PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line">3 export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br></pre></td></tr></table></figure></div><ol start="5"><li>测试安装<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 [root@miyakh ~]# java -version</span><br><span class="line">2 [root@miyakh ~]# java</span><br><span class="line">3 [root@miyakh ~]# javac</span><br></pre></td></tr></table></figure></div></li></ol><h2 id="安装-Nacos"><a href="#安装-Nacos" class="headerlink" title="安装 Nacos"></a>安装 Nacos</h2><blockquote><p>本项目需要使用 Nacos 作为 Dubbo 的注册中心</p></blockquote><ol><li>下载 Nacos 压缩文件</li></ol><p><a class="link"   href="https://github.com/alibaba/nacos/releases" >https://github.com/alibaba/nacos/releases <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><ol start="2"><li><p>上传到云服务器<code>/opt/downfile</code> 目录</p></li><li><p>解压安装包到 <code>/opt/software</code> 目录</p><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@miykah downfile]# tar -zxvf nacos-server-2.2.2.tar.gz -C /opt/software/</span><br></pre></td></tr></table></figure></div></li><li><p>启动Nacos</p><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@miykah bin]# sh startup.sh -m standalone</span><br><span class="line">/opt/software/jdk1.8.0_361/bin/java -Djava.ext.dirs=/opt/software/jdk1.8.0_361/jre/lib/ext:/opt/software/jdk1.8.0_361/lib/ext  -Xms512m -Xmx512m -Xmn256m -Dnacos.standalone=true -Dnacos.member.list= -Xloggc:/opt/software/nacos/logs/nacos_gc.log -verbose:gc -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCTimeStamps -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=10 -XX:GCLogFileSize=100M -Dloader.path=/opt/software/nacos/plugins,/opt/software/nacos/plugins/health,/opt/software/nacos/plugins/cmdb,/opt/software/nacos/plugins/selector -Dnacos.home=/opt/software/nacos -jar /opt/software/nacos/target/nacos-server.jar  --spring.config.additional-location=file:/opt/software/nacos/conf/ --logging.config=/opt/software/nacos/conf/nacos-logback.xml --server.max-http-header-size=524288</span><br><span class="line">nacos is starting with standalone</span><br><span class="line">nacos is starting，you can check the /opt/software/nacos/logs/start.out</span><br></pre></td></tr></table></figure></div><p>查看 nacos 日志看看是否启动成功</p><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat  /opt/software/nacos/logs/start.out</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.nlark.com/yuque/0/2023/png/35923527/1684835390931-2c862064-bb7a-4ef5-b25e-d3714d48aa39.png#averageHue=%2310161c&clientId=u0918ef5a-1737-4&from=paste&height=489&id=u5b07530d&originHeight=673&originWidth=1121&originalType=binary&ratio=1.375&rotation=0&showTitle=false&size=59663&status=done&style=none&taskId=u59091839-d605-4dba-af19-04de273e00e&title=&width=815.2727272727273"                      alt="image.png"                ></p></li><li><p>访问 Nacos 主页</p></li></ol><p><a class="link"   href="http://服务器ip:8848/nacos" >http:&#x2F;&#x2F;服务器IP:8848&#x2F;nacos <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>&#x2F;</p><h2 id="后端项目部署"><a href="#后端项目部署" class="headerlink" title="后端项目部署"></a>后端项目部署</h2><h3 id="打包后端项目"><a href="#打包后端项目" class="headerlink" title="打包后端项目"></a>打包后端项目</h3><ol><li><p>更改后端配置文件</p><div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">phmapi-backend</span></span><br><span class="line">  <span class="comment"># DataSource Config</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/phmapi</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root2</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root2</span></span><br><span class="line">  <span class="attr">mvc:</span></span><br><span class="line">    <span class="attr">pathmatch:</span></span><br><span class="line">      <span class="attr">matching-strategy:</span> <span class="string">ANT_PATH_MATCHER</span></span><br><span class="line">  <span class="comment"># session 失效时间（分钟）</span></span><br><span class="line">  <span class="attr">session:</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="number">86400</span></span><br><span class="line">    <span class="attr">store-type:</span> <span class="string">redis</span></span><br><span class="line">  <span class="comment"># redis 配置</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">1</span>  <span class="comment"># database0是之前黑马点评在用，避免混乱，这里存在database1</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">Ranmaoqi0718</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">7529</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line">    <span class="attr">context-path:</span> <span class="string">/api</span></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">map-underscore-to-camel-case:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">logic-delete-field:</span> <span class="string">isDelete</span> <span class="comment"># 全局逻辑删除的实体字段名(since 3.3.0,配置后可以忽略不配置步骤2)</span></span><br><span class="line">      <span class="attr">logic-delete-value:</span> <span class="number">1</span> <span class="comment"># 逻辑已删除值(默认为 1)</span></span><br><span class="line">      <span class="attr">logic-not-delete-value:</span> <span class="number">0</span> <span class="comment"># 逻辑未删除值(默认为 0)</span></span><br><span class="line"><span class="attr">phmapi:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">access-key:</span> <span class="string">34713006f9ba482bbd8f5d695d58da9d</span></span><br><span class="line">    <span class="attr">secret-key:</span> <span class="string">dbba2bf9cd1648f4bf59db21dcfb3a4c</span></span><br><span class="line"></span><br><span class="line"><span class="attr">dubbo:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">dubbo-springboot-demo-provider</span></span><br><span class="line">  <span class="attr">protocol:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">dubbo</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">-1</span></span><br><span class="line">  <span class="attr">registry:</span></span><br><span class="line">    <span class="attr">id:</span> <span class="string">nacos-registry</span></span><br><span class="line">    <span class="attr">address:</span> <span class="string">nacos://localhost:8848</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div></li><li><p>运行 maven clean 后运行 maven package</p></li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.nlark.com/yuque/0/2023/png/35923527/1684836740368-5f3ca459-1a41-4240-8d83-cbe31d1a951d.png#averageHue=%233b4044&clientId=u0918ef5a-1737-4&from=paste&height=246&id=u04f864de&originHeight=338&originWidth=354&originalType=binary&ratio=1.375&rotation=0&showTitle=false&size=17875&status=done&style=none&taskId=u08b18b34-660f-4b3a-8e32-64b6a646226&title=&width=257.45454545454544"                      alt="image.png"                ></p><ol start="3"><li>将打包好的 <code>jar</code>文件改个简单名，上传到服务器</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.nlark.com/yuque/0/2023/png/35923527/1684836774095-61cbfae6-bedc-44a7-85c6-0d88cde61e40.png#averageHue=%23504c42&clientId=u0918ef5a-1737-4&from=paste&height=133&id=u62afcae1&originHeight=183&originWidth=361&originalType=binary&ratio=1.375&rotation=0&showTitle=false&size=8307&status=done&style=none&taskId=uf0930859-5114-4d92-8be1-cbc464f976d&title=&width=262.54545454545456"                      alt="image.png"                ><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.nlark.com/yuque/0/2023/png/35923527/1684837323956-3f436382-7d1b-42f9-be1f-9c9e4f520693.png#averageHue=%23f7f4f0&clientId=u0918ef5a-1737-4&from=paste&height=47&id=u9a12a7d6&originHeight=64&originWidth=332&originalType=binary&ratio=1.375&rotation=0&showTitle=false&size=5818&status=done&style=none&taskId=ucc6e7a82-8521-45b4-987d-ee56d540bd4&title=&width=241.45454545454547"                      alt="image.png"                ></p><blockquote><p>同样的操作 对于 <code>phmapi-gateway</code>和 <code>phmapi-interface</code><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.nlark.com/yuque/0/2023/png/35923527/1684837535874-db0846f1-2edf-4452-a6e4-9be3d252e098.png#averageHue=%23f4f0eb&clientId=u2e175b83-982d-4&from=paste&height=62&id=u3e18fde7&originHeight=85&originWidth=648&originalType=binary&ratio=1.375&rotation=0&showTitle=false&size=12970&status=done&style=none&taskId=u0ca56967-30ca-4a53-9145-af931ce0b63&title=&width=471.27272727272725"                      alt="image.png"                ></p></blockquote><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><blockquote><p>可以使用 nohup java -jar命令运行这几个jar包。<br>但为了方便可视化操作，以及在宝塔查看运行日志，使用宝塔运行项目</p></blockquote><p>以 <code>phmapi-backend</code> 为例，在<strong>宝塔面板-网站-Java项目</strong>中新建Java项目，选择 Spring Boot 项目<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.nlark.com/yuque/0/2023/png/35923527/1684844207261-0bf1bbba-496f-4b46-b2c4-aead6f790b54.png#averageHue=%23f9f9f9&clientId=u2e175b83-982d-4&from=paste&height=496&id=u0aea1ada&originHeight=682&originWidth=714&originalType=binary&ratio=1.375&rotation=0&showTitle=false&size=51050&status=done&style=none&taskId=uef231a0a-65e8-48cb-acb7-d8df0d93300&title=&width=519.2727272727273"                      alt="image.png"                ><br>设置好端口即可运行，<code>phmapi-gateway</code> 和 <code>phmapi-interface</code> 同理。<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.nlark.com/yuque/0/2023/png/35923527/1684844255784-2efcc288-1d24-4c97-9428-fabbcb92bb3a.png#averageHue=%23fbfaf9&clientId=u2e175b83-982d-4&from=paste&height=158&id=u8896f029&originHeight=217&originWidth=1092&originalType=binary&ratio=1.375&rotation=0&showTitle=false&size=26932&status=done&style=none&taskId=ud83106e9-8cbf-46a5-9489-38bfd9498f2&title=&width=794.1818181818181"                      alt="image.png"                ></p><h2 id="前端项目部署"><a href="#前端项目部署" class="headerlink" title="前端项目部署"></a>前端项目部署</h2><blockquote><p>部署前端项目需要安装 nginx， 使用宝塔软件商店安装。<br>安装目录默认在 <code>/www/server/nginx</code></p></blockquote><h3 id="打包前端项目"><a href="#打包前端项目" class="headerlink" title="打包前端项目"></a>打包前端项目</h3><ol><li>首先需要修改前端项目中 <code>src/requestConfig.rs</code> 文件，将 <code>baseURL</code>改为服务器的host，并且不能是 localhost（试了一次使用 localhost 请求不到后端项目）</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.nlark.com/yuque/0/2023/png/35923527/1684844392782-aba674a6-efb4-4ba3-8cba-e8827e18c894.png#averageHue=%232f2d2c&clientId=u2e175b83-982d-4&from=paste&height=80&id=u59226d5e&originHeight=110&originWidth=440&originalType=binary&ratio=1.375&rotation=0&showTitle=false&size=18988&status=done&style=none&taskId=ue29b1866-a4ee-40cf-a71b-883ea06b7d2&title=&width=320"                      alt="image.png"                ></p><ol start="2"><li>执行 <code>npm run build</code> 打包前端项目，会在项目目录下生成 <code>dist</code>文件夹，拷贝文件夹到服务器的 <code>/opt/frontend_file</code>目录，并改名为 phmapi-frontend<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">root@miykah</span> <span class="string">frontend_file</span>]<span class="comment"># ll</span></span><br><span class="line"><span class="string">总用量</span> <span class="number">4</span></span><br><span class="line"><span class="string">drwxr-xr-x</span> <span class="number">4</span> <span class="string">root</span> <span class="string">root</span> <span class="number">4096 </span><span class="number">5</span><span class="string">月</span>  <span class="number">23</span> <span class="number">19</span><span class="string">:47</span> <span class="string">phmapi-frontend</span></span><br></pre></td></tr></table></figure></div></li></ol><h3 id="修改-nginx-配置文件"><a href="#修改-nginx-配置文件" class="headerlink" title="修改 nginx 配置文件"></a>修改 nginx 配置文件</h3><p>修改 <code>/www/server/nginx/conf/nginx.conf</code> 文件，添加如下：</p><div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">server</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">listen</span> <span class="number">8000</span><span class="string">;</span></span><br><span class="line">      <span class="string">server_name</span> <span class="string">localhost;</span></span><br><span class="line">      </span><br><span class="line">      <span class="string">location</span> <span class="string">/</span> &#123;</span><br><span class="line">        <span class="string">root</span> <span class="string">/opt/frontend_file/phmapi-frontend;</span></span><br><span class="line">        <span class="string">index</span> <span class="string">index.html</span> <span class="string">index.htm;</span></span><br><span class="line">        <span class="string">try_files</span>  <span class="string">$uri</span> <span class="string">$uri/</span> <span class="string">/index.html;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><p>重载 nginx 配置：</p><div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">nginx</span> <span class="string">-s</span> <span class="string">reload</span></span><br></pre></td></tr></table></figure></div><p>访问 <a class="link"   href="http://139.155.144.134:8000/" >http://139.155.144.134:8000/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 成功！</p><h3 id="BUG解决：前端界面跳转页面的时候404"><a href="#BUG解决：前端界面跳转页面的时候404" class="headerlink" title="BUG解决：前端界面跳转页面的时候404"></a>BUG解决：前端界面跳转页面的时候404</h3><p>上面前端部署完成之后，可以正常登录进入首页，但是点击页面的某些地方，需要跳转到另一页面的时候，出现404<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.nlark.com/yuque/0/2023/png/35923527/1684845068843-4eee72ff-500b-4254-8507-6088f7b811d7.png#averageHue=%23f1f0ef&clientId=u2e175b83-982d-4&from=paste&height=100&id=u60c9f64c&originHeight=137&originWidth=341&originalType=binary&ratio=1.375&rotation=0&showTitle=false&size=5031&status=done&style=none&taskId=uf304f8d1-c7b9-429c-ac8f-0649f81f85e&title=&width=248"                      alt="image.png"                ><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.nlark.com/yuque/0/2023/png/35923527/1684845112001-a0d0adb6-46b3-4c13-85e9-acfece450f6a.png#averageHue=%23fefdfd&clientId=u2e175b83-982d-4&from=paste&height=108&id=u6ed2c870&originHeight=148&originWidth=593&originalType=binary&ratio=1.375&rotation=0&showTitle=false&size=34857&status=done&style=none&taskId=uefe467ed-9f47-4b48-8c8c-43d50261dfb&title=&width=431.27272727272725"                      alt="image.png"                ><br><strong>原因分析：</strong><br>原因是因为web单页面开发模式，只有一个index.html入口，其他路径是前端路由去跳转的，nginx没有对应这个路径，当然就是404了。<br><strong>解决办法：</strong><br>在 nginx 配置文件中修改如下：</p><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server</span><br><span class="line">    &#123;</span><br><span class="line">      listen 8000;</span><br><span class="line">      server_name localhost;</span><br><span class="line">      </span><br><span class="line">      location / &#123;</span><br><span class="line">        root /opt/frontend_file/phmapi-frontend;</span><br><span class="line">        index index.html index.htm;</span><br><span class="line">        try_files  $uri $uri/ /index.html;  # 添加这行配置</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><p>在配置中加上try_files，意思跟翻译差不多，“尝试读取文件”。uri 这个是 nginx 的一个变量 ，存放着用户访问的地址 , 例 如 <a class="link"   href="http://localhost:8200/chooseSize" >http://localhost:8200/chooseSize <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>  那 么 uri 这个是nginx的一个变量，存放着用户访问的地址,例如<a class="link"   href="http://localhost:8200/chooseSize" >http://localhost:8200/chooseSize <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 那么uri这个是nginx的一个变量，存放着用户访问的地址,例如<a class="link"   href="http://localhost:8200/chooseSize" >http://localhost:8200/chooseSize <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>那么uri就是&#x2F;chooseSize；u r i &#x2F; 代 表 访 问 的 是 一 个 目 录 例 如 <a class="link"   href="http://localhost:8200/chooseSize" >http://localhost:8200/chooseSize <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>&#x2F;，那 么 uri&#x2F; 代表访问的是一个目录 例如<a class="link"   href="http://localhost:8200/chooseSize/" >http://localhost:8200/chooseSize/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 那么uri&#x2F;代表访问的是一个目录例如<a class="link"   href="http://localhost:8200/chooseSize/" >http://localhost:8200/chooseSize/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>那么uri&#x2F;就是&#x2F;chooseSize&#x2F;；最后&#x2F;index.html就是我们首页的地址。<br>最终上面的意思是如果第一个存在，直接返回；不存在的话读取第二个，如果存在，读取返回；如果还是不存在，就会fall back到 try_files 的最后一个选项 &#x2F;index.html,发起一个内部 “子请求”，也就是相当于 nginx 发起一个 HTTP 请求到 <a class="link"   href="http://localhost:8200/index.html" >http://localhost:8200/index.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，再通过前端路由到&#x2F;chooseSize。</p><h3 id="BUG解决：点击测试接口，但一直没反应"><a href="#BUG解决：点击测试接口，但一直没反应" class="headerlink" title="BUG解决：点击测试接口，但一直没反应"></a>BUG解决：点击测试接口，但一直没反应</h3><p>发现服务器数据库中，接口的 url 都是172.168.9.61 而不是服务器的 ip ，当然没反应。<br>改了之后就成功勒</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;项目背景&quot;&gt;&lt;a href=&quot;#项目背景&quot; class=&quot;headerlink&quot; title=&quot;项目背景&quot;&gt;&lt;/a&gt;项目背景&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;设想：这是API开放平台，而不是API管理平台。面试官可能会说，可以使用已有的如Swagger这样</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>乐观锁和悲观锁</title>
    <link href="https://miykah.top/2023/05/29/%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81/"/>
    <id>https://miykah.top/2023/05/29/%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81/</id>
    <published>2023-05-29T01:55:08.000Z</published>
    <updated>2023-05-29T02:01:54.922Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是悲观锁？"><a href="#什么是悲观锁？" class="headerlink" title="什么是悲观锁？"></a>什么是悲观锁？</h1><p>悲观锁总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。也就是说，<strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</strong>。</p><p>像 Java 中<code>synchronized</code>和<code>ReentrantLock</code>等独占锁就是悲观锁思想的实现。</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">performSynchronisedTask</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="comment">// 需要同步的操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="comment">// 需要同步的操作</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>高并发的场景下，激烈的锁竞争会造成线程阻塞，大量阻塞线程会导致系统的上下文切换，增加系统的性能开销。并且，悲观锁还可能会存在死锁问题，影响代码的正常运行。</p><h1 id="什么是乐观锁？"><a href="#什么是乐观锁？" class="headerlink" title="什么是乐观锁？"></a>什么是乐观锁？</h1><p>乐观锁总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源（也就是数据）是否被其它线程修改了（具体方法可以使用版本号机制或 CAS 算法）。</p><p>在 Java 中<code>java.util.concurrent.atomic</code>包下面的原子变量类（比如<code>AtomicInteger</code>、<code>LongAdder</code>）就是使用了乐观锁的一种实现方式 <strong>CAS</strong> 实现的。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://miykah-imagebed.oss-cn-chengdu.aliyuncs.com/img/202305290956687.png"                      alt="JUC原子类概览"                ></p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LongAdder 在高并发场景下会比 AtomicInteger 和 AtomicLong 的性能更好</span></span><br><span class="line"><span class="comment">// 代价就是会消耗更多的内存空间（空间换时间）</span></span><br><span class="line"><span class="type">LongAdder</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongAdder</span>();</span><br><span class="line">sum.increment();</span><br></pre></td></tr></table></figure></div><p>高并发的场景下，乐观锁相比悲观锁来说，不存在锁竞争造成线程阻塞，也不会有死锁的问题，在性能上往往会更胜一筹。但是，如果冲突频繁发生（写占比非常多的情况），会频繁失败和重试，这样同样会非常影响性能，导致 CPU 飙升。</p><p>不过，大量失败重试的问题也是可以解决的，像我们前面提到的 <code>LongAdder</code>以空间换时间的方式就解决了这个问题。</p><p>理论上来说：</p><ul><li>悲观锁通常多用于写比较多的情况下（多写场景，竞争激烈），这样可以避免频繁失败和重试影响性能，悲观锁的开销是固定的。不过，如果乐观锁解决了频繁失败和重试这个问题的话（比如<code>LongAdder</code>），也是可以考虑使用乐观锁的，要视实际情况而定。</li><li>乐观锁通常多于写比较少的情况下（多读场景，竞争较少），这样可以避免频繁加锁影响性能。不过，乐观锁主要针对的对象是单个共享变量（参考<code>java.util.concurrent.atomic</code>包下面的原子变量类）。</li></ul><h2 id="如何实现乐观锁？"><a href="#如何实现乐观锁？" class="headerlink" title="如何实现乐观锁？"></a>如何实现乐观锁？</h2><p>乐观锁一般会使用版本号机制或 CAS 算法实现，CAS 算法相对来说更多一些，这里需要格外注意。</p><h3 id="版本号机制"><a href="#版本号机制" class="headerlink" title="版本号机制"></a>版本号机制</h3><p>一般是在数据表中加上一个数据版本号 <code>version</code> 字段，表示数据被修改的次数。当数据被修改时，<code>version</code> 值会加一。当线程 A 要更新数据值时，在读取数据的同时也会读取 <code>version</code> 值，在提交更新时，若刚才读取到的 version 值为当前数据库中的 <code>version</code> 值相等时才更新，否则重试更新操作，直到更新成功。</p><p><strong>举一个简单的例子</strong>：假设数据库中帐户信息表中有一个 version 字段，当前值为 1 ；而当前帐户余额字段（ <code>balance</code> ）为 $100 。</p><ol><li>操作员 A 此时将其读出（ <code>version</code>&#x3D;1 ），并从其帐户余额中扣除 $50（ $100-$50 ）。</li><li>在操作员 A 操作的过程中，操作员 B 也读入此用户信息（ <code>version</code>&#x3D;1 ），并从其帐户余额中扣除 $20 （ $100-$20 ）。</li><li>操作员 A 完成了修改工作，将数据版本号（ <code>version</code>&#x3D;1 ），连同帐户扣除后余额（ <code>balance</code>&#x3D;$50 ），提交至数据库更新，此时由于提交数据版本等于数据库记录当前版本，数据被更新，数据库记录 <code>version</code> 更新为 2 。</li><li>操作员 B 完成了操作，也将版本号（ <code>version</code>&#x3D;1 ）试图向数据库提交数据（ <code>balance</code>&#x3D;$80 ），但此时比对数据库记录版本时发现，操作员 B 提交的数据版本号为 1 ，数据库记录当前版本也为 2 ，不满足 “ 提交版本必须等于当前版本才能执行更新 “ 的乐观锁策略，因此，操作员 B 的提交被驳回。</li></ol><p>这样就避免了操作员 B 用基于 <code>version</code>&#x3D;1 的旧数据修改的结果覆盖操作员 A 的操作结果的可能。</p><h3 id="CAS-算法"><a href="#CAS-算法" class="headerlink" title="CAS 算法"></a>CAS 算法</h3><p>CAS 的全称是 <strong>Compare And Swap（比较与交换）</strong> ，用于实现乐观锁，被广泛应用于各大框架中。CAS 的思想很简单，就是用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。</p><p>CAS 是一个原子操作，底层依赖于一条 CPU 的原子指令。</p><blockquote><p><strong>原子操作</strong> 即最小不可拆分的操作，也就是说操作一旦开始，就不能被打断，直到操作完成。</p></blockquote><p>CAS 涉及到三个操作数：</p><ul><li><strong>V</strong>：要更新的变量值(Var)</li><li><strong>E</strong>：预期值(Expected)</li><li><strong>N</strong>：拟写入的新值(New)</li></ul><p>当且仅当 V 的值等于 E 时，CAS 通过原子方式用新值 N 来更新 V 的值。如果不等，说明已经有其它线程更新了 V，则当前线程放弃更新。</p><p><strong>举一个简单的例子</strong>：线程 A 要修改变量 i 的值为 6，i 原值为 1（V &#x3D; 1，E&#x3D;1，N&#x3D;6，假设不存在 ABA 问题）。</p><ol><li>i 与 1 进行比较，如果相等， 则说明没被其他线程修改，可以被设置为 6 。</li><li>i 与 1 进行比较，如果不相等，则说明被其他线程修改，当前线程放弃更新，CAS 操作失败。</li></ol><p>当多个线程同时使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。</p><p>Java 语言并没有直接实现 CAS，CAS 相关的实现是通过 C++ 内联汇编的形式实现的（JNI 调用）。因此， CAS 的具体实现和操作系统以及 CPU 都有关系。</p><p><code>sun.misc</code>包下的<code>Unsafe</code>类提供了<code>compareAndSwapObject</code>、<code>compareAndSwapInt</code>、<code>compareAndSwapLong</code>方法来实现的对<code>Object</code>、<code>int</code>、<code>long</code>类型的 CAS 操作</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  CAS</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> o         包含要修改field的对象</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> offset    对象中某field的偏移量</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> expected  期望值</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> update    更新值</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span>          true | false</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapObject</span><span class="params">(Object o, <span class="type">long</span> offset,  Object expected, Object update)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapInt</span><span class="params">(Object o, <span class="type">long</span> offset, <span class="type">int</span> expected,<span class="type">int</span> update)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapLong</span><span class="params">(Object o, <span class="type">long</span> offset, <span class="type">long</span> expected, <span class="type">long</span> update)</span>;</span><br></pre></td></tr></table></figure></div><h2 id="乐观锁存在哪些问题？"><a href="#乐观锁存在哪些问题？" class="headerlink" title="乐观锁存在哪些问题？"></a>乐观锁存在哪些问题？</h2><p>ABA 问题是乐观锁最常见的问题。</p><h3 id="ABA-问题"><a href="#ABA-问题" class="headerlink" title="ABA 问题"></a>ABA 问题</h3><p>如果一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然是 A 值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回 A，那 CAS 操作就会误认为它从来没有被修改过。这个问题被称为 CAS 操作的 <strong>“ABA”问题。</strong></p><p>ABA 问题的解决思路是在变量前面追加上<strong>版本号或者时间戳</strong>。JDK 1.5 以后的 <code>AtomicStampedReference</code> 类就是用来解决 ABA 问题的，其中的 <code>compareAndSet()</code> 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(V   expectedReference,</span></span><br><span class="line"><span class="params">                             V   newReference,</span></span><br><span class="line"><span class="params">                             <span class="type">int</span> expectedStamp,</span></span><br><span class="line"><span class="params">                             <span class="type">int</span> newStamp)</span> &#123;</span><br><span class="line">    Pair&lt;V&gt; current = pair;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">        expectedReference == current.reference &amp;&amp;</span><br><span class="line">        expectedStamp == current.stamp &amp;&amp;</span><br><span class="line">        ((newReference == current.reference &amp;&amp;</span><br><span class="line">          newStamp == current.stamp) ||</span><br><span class="line">         casPair(current, Pair.of(newReference, newStamp)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="循环时间长开销大"><a href="#循环时间长开销大" class="headerlink" title="循环时间长开销大"></a>循环时间长开销大</h3><p>CAS 经常会用到自旋操作来进行重试，也就是不成功就一直循环执行直到成功。如果长时间不成功，会给 CPU 带来非常大的执行开销。</p><p>如果 JVM 能支持处理器提供的 pause 指令那么效率会有一定的提升，pause 指令有两个作用：</p><ol><li>可以延迟流水线执行指令，使 CPU 不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。</li><li>可以避免在退出循环的时候因内存顺序冲而引起 CPU 流水线被清空，从而提高 CPU 的执行效率。</li></ol><h3 id="只能保证一个共享变量的原子操作"><a href="#只能保证一个共享变量的原子操作" class="headerlink" title="只能保证一个共享变量的原子操作"></a>只能保证一个共享变量的原子操作</h3><p>CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5 开始，提供了<code>AtomicReference</code>类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是悲观锁？&quot;&gt;&lt;a href=&quot;#什么是悲观锁？&quot; class=&quot;headerlink&quot; title=&quot;什么是悲观锁？&quot;&gt;&lt;/a&gt;什么是悲观锁？&lt;/h1&gt;&lt;p&gt;悲观锁总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以每次在</summary>
      
    
    
    
    <category term="Java" scheme="https://miykah.top/categories/Java/"/>
    
    
    <category term="锁" scheme="https://miykah.top/tags/%E9%94%81/"/>
    
    <category term="并发" scheme="https://miykah.top/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>如何实现分布式锁？</title>
    <link href="https://miykah.top/2023/05/27/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%EF%BC%9F/"/>
    <id>https://miykah.top/2023/05/27/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%EF%BC%9F/</id>
    <published>2023-05-27T11:33:08.000Z</published>
    <updated>2023-05-28T07:36:55.587Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文源自 <a class="link"   href="https://javaguide.cn/" >https://javaguide.cn/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></blockquote><h1 id="分布式锁介绍"><a href="#分布式锁介绍" class="headerlink" title="分布式锁介绍"></a>分布式锁介绍</h1><p>对于单机多线程来说，在 Java 中，我们通常使用 <code>ReetrantLock</code> 类、<code>synchronized</code> 关键字这类 JDK 自带的 <strong>本地锁</strong> 来控制一个 JVM 进程内的多个线程对本地共享资源的访问。</p><p>下面是我对本地锁画的一张示意图。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://miykah-imagebed.oss-cn-chengdu.aliyuncs.com/img/202305271941930.png"                      alt="image-20230316200452106"                ></p><p>从图中可以看出，这些线程访问共享资源是互斥的，同一时刻只有一个线程可以获取到本地锁访问共享资源。</p><p>分布式系统下，不同的服务&#x2F;客户端通常运行在独立的 JVM 进程上。如果多个 JVM 进程共享同一份资源的话，使用本地锁就没办法实现资源的互斥访问了。于是，<strong>分布式锁</strong> 就诞生了。</p><p>举个例子：系统的订单服务一共部署了 3 份，都对外提供服务。用户下订单之前需要检查库存，为了防止超卖，这里需要加锁以实现对检查库存操作的同步访问。由于订单服务位于不同的 JVM 进程中，本地锁在这种情况下就没办法正常工作了。我们需要用到分布式锁，这样的话，即使多个线程不在同一个 JVM 进程中也能获取到同一把锁，进而实现共享资源的互斥访问。</p><p>下面是我对分布式锁画的一张示意图。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://miykah-imagebed.oss-cn-chengdu.aliyuncs.com/img/202305271941940.png"                      alt="image-20230316200431956"                ></p><p>从图中可以看出，这些独立的进程中的线程访问共享资源是互斥的，同一时刻只有一个线程可以获取到分布式锁访问共享资源。</p><p>一个最基本的分布式锁需要满足：</p><ul><li><strong>互斥</strong> ：任意一个时刻，锁只能被一个线程持有；</li><li><strong>高可用</strong> ：锁服务是高可用的。并且，即使客户端的释放锁的代码逻辑出现问题，锁最终一定还是会被释放，不会影响其他线程对共享资源的访问。</li><li><strong>可重入</strong>：一个节点获取了锁之后，还可以再次获取锁。</li></ul><p>通常情况下，我们一般会选择基于 Redis 或者 ZooKeeper 实现分布式锁，Redis 用的要更多一点，我这里也以 Redis 为例介绍分布式锁的实现。</p><h1 id="基于-Redis-实现分布式锁"><a href="#基于-Redis-实现分布式锁" class="headerlink" title="基于 Redis 实现分布式锁"></a>基于 Redis 实现分布式锁</h1><h2 id="如何基于-Redis-实现一个最简易的分布式锁？"><a href="#如何基于-Redis-实现一个最简易的分布式锁？" class="headerlink" title="如何基于 Redis 实现一个最简易的分布式锁？"></a>如何基于 Redis 实现一个最简易的分布式锁？</h2><p>不论是本地锁还是分布式锁，核心都在于“互斥”。</p><p>在 Redis 中， <code>SETNX</code> 命令是可以帮助我们实现互斥。<code>SETNX</code> 即 <strong>SET</strong> if <strong>N</strong>ot e<strong>X</strong>ists (对应 Java 中的 <code>setIfAbsent</code> 方法)，如果 key 不存在的话，才会设置 key 的值。如果 key 已经存在， <code>SETNX</code> 啥也不做。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; SETNX lockKey uniqueValue</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">&gt; SETNX lockKey uniqueValue</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure></div><p>释放锁的话，直接通过 <code>DEL</code> 命令删除对应的 key 即可。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; DEL lockKey</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure></div><p>为了防止误删到其他的锁，这里我们建议使用 Lua 脚本通过 key 对应的 value（唯一值）来判断。</p><p>选用 Lua 脚本是为了保证解锁操作的原子性。因为 Redis 在执行 Lua 脚本时，可以以原子性的方式执行，从而保证了锁释放操作的原子性。</p><div class="highlight-container" data-rel="Lua"><figure class="iseeu highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 释放锁时，先比较锁对应的 value 值是否相等，避免锁的误释放</span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;get&quot;</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&quot;del&quot;</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://miykah-imagebed.oss-cn-chengdu.aliyuncs.com/img/202305271941951.png"                      alt="image-20230316202045526"                ></p><p>这是一种最简易的 Redis 分布式锁实现，实现方式比较简单，性能也很高效。不过，这种方式实现分布式锁存在一些问题。就比如应用程序遇到一些问题比如释放锁的逻辑突然挂掉，可能会导致锁无法被释放，进而造成共享资源无法再被其他线程&#x2F;进程访问。</p><h2 id="为什么要给锁设置一个过期时间？"><a href="#为什么要给锁设置一个过期时间？" class="headerlink" title="为什么要给锁设置一个过期时间？"></a>为什么要给锁设置一个过期时间？</h2><p>为了避免锁无法被释放，我们可以想到的一个解决办法就是： <strong>给这个 key（也就是锁） 设置一个过期时间</strong> 。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SET lockKey uniqueValue EX 3 NX</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></div><ul><li><strong>lockKey</strong> ：加锁的锁名；</li><li><strong>uniqueValue</strong> ：能够唯一标示锁的随机字符串；</li><li><strong>NX</strong> ：只有当 lockKey 对应的 key 值不存在的时候才能 SET 成功；</li><li><strong>EX</strong> ：过期时间设置（秒为单位）EX 3 标示这个锁有一个 3 秒的自动过期时间。与 EX 对应的是 PX（毫秒为单位），这两个都是过期时间设置。</li></ul><p><strong>一定要保证设置指定 key 的值和过期时间是一个原子操作！！！</strong> 不然的话，依然可能会出现锁无法被释放的问题。</p><p>这样确实可以解决问题，不过，这种解决办法同样存在漏洞：<strong>如果操作共享资源的时间大于过期时间，就会出现锁提前过期的问题，进而导致分布式锁直接失效。如果锁的超时时间设置过长，又会影响到性能。</strong></p><p>你或许在想： <strong>如果操作共享资源的操作还未完成，锁过期时间能够自己续期就好了！</strong></p><h2 id="如何实现锁的优雅续期？"><a href="#如何实现锁的优雅续期？" class="headerlink" title="如何实现锁的优雅续期？"></a>如何实现锁的优雅续期？</h2><p>对于 Java 开发的小伙伴来说，已经有了现成的解决方案：**<a class="link"   href="https://github.com/redisson/redisson" >Redisson <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>** 。其他语言的解决方案，可以在 Redis 官方文档中找到.</p><p>Redisson 是一个开源的 Java 语言 Redis 客户端，提供了很多开箱即用的功能，不仅仅包括多种分布式锁的实现。并且，Redisson 还支持 Redis 单机、Redis Sentinel 、Redis Cluster 等多种部署架构。</p><p>Redisson 中的分布式锁自带自动续期机制，使用起来非常简单，原理也比较简单，其提供了一个专门用来监控和续期锁的 <strong>Watch Dog（ 看门狗）</strong>，如果操作共享资源的线程还未执行完成的话，Watch Dog 会不断地延长锁的过期时间，进而保证锁不会因为超时而被释放。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://miykah-imagebed.oss-cn-chengdu.aliyuncs.com/img/202305271941944.png"                      alt="image-20230316203137541"                ></p><p>看门狗名字的由来于 <code>getLockWatchdogTimeout()</code> 方法，这个方法返回的是看门狗给锁续期的过期时间，默认为 30 秒（<a class="link"   href="https://github.com/redisson/redisson/releases/tag/redisson-3.17.6" >redisson-3.17.6 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>）。</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认 30秒，支持修改</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="variable">lockWatchdogTimeout</span> <span class="operator">=</span> <span class="number">30</span> * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Config <span class="title function_">setLockWatchdogTimeout</span><span class="params">(<span class="type">long</span> lockWatchdogTimeout)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.lockWatchdogTimeout = lockWatchdogTimeout;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getLockWatchdogTimeout</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> lockWatchdogTimeout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><code>renewExpiration()</code> 方法包含了看门狗的主要逻辑：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">renewExpiration</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="comment">//......</span></span><br><span class="line">        <span class="type">Timeout</span> <span class="variable">task</span> <span class="operator">=</span> commandExecutor.getConnectionManager().newTimeout(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(Timeout timeout)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="comment">//......</span></span><br><span class="line">                <span class="comment">// 异步续期，基于 Lua 脚本</span></span><br><span class="line">                CompletionStage&lt;Boolean&gt; future = renewExpirationAsync(threadId);</span><br><span class="line">                future.whenComplete((res, e) -&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 无法续期</span></span><br><span class="line">                        log.error(<span class="string">&quot;Can&#x27;t update lock &quot;</span> + getRawName() + <span class="string">&quot; expiration&quot;</span>, e);</span><br><span class="line">                        EXPIRATION_RENEWAL_MAP.remove(getEntryName());</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (res) &#123;</span><br><span class="line">                        <span class="comment">// 递归调用实现续期</span></span><br><span class="line">                        renewExpiration();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 取消续期</span></span><br><span class="line">                        cancelExpirationRenewal(<span class="literal">null</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">         <span class="comment">// 延迟 internalLockLeaseTime/3（默认 10s，也就是 30/3） 再调用</span></span><br><span class="line">        &#125;, internalLockLeaseTime / <span class="number">3</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">        ee.setTimeout(task);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><p>默认情况下，每过 10 秒，看门狗就会执行续期操作，将锁的超时时间设置为 30 秒。看门狗续期前也会先判断是否需要执行续期操作，需要才会执行续期，否则取消续期操作。</p><p>Watch Dog 通过调用 <code>renewExpirationAsync()</code> 方法实现锁的异步续期：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> CompletionStage&lt;Boolean&gt; <span class="title function_">renewExpirationAsync</span><span class="params">(<span class="type">long</span> threadId)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> evalWriteAsync(getRawName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,</span><br><span class="line">            <span class="comment">// 判断是否为持锁线程，如果是就执行续期操作，就锁的过期时间设置为 30s（默认）</span></span><br><span class="line">            <span class="string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;return 1; &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;return 0;&quot;</span>,</span><br><span class="line">            Collections.singletonList(getRawName()),</span><br><span class="line">            internalLockLeaseTime, getLockName(threadId));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>可以看出， <code>renewExpirationAsync</code> 方法其实是调用 Lua 脚本实现的续期，这样做主要是为了保证续期操作的原子性。</p><p>我这里以 Redisson 的分布式可重入锁 <code>RLock</code> 为例来说明如何使用 Redisson 实现分布式锁：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.获取指定的分布式锁对象</span></span><br><span class="line"><span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redisson.getLock(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line"><span class="comment">// 2.拿锁且不设置锁超时时间，具备 Watch Dog 自动续期机制</span></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="comment">// 3.执行业务</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// 4.释放锁</span></span><br><span class="line">lock.unlock();</span><br></pre></td></tr></table></figure></div><p>只有未指定锁超时时间，才会使用到 Watch Dog 自动续期机制。</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手动给锁设置过期时间，不具备 Watch Dog 自动续期机制</span></span><br><span class="line">lock.lock(<span class="number">10</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure></div><p>如果使用 Redis 来实现分布式锁的话，还是比较推荐直接基于 Redisson 来做的。</p><h2 id="如何实现可重入锁？"><a href="#如何实现可重入锁？" class="headerlink" title="如何实现可重入锁？"></a>如何实现可重入锁？</h2><p>所谓可重入锁指的是在一个线程中可以多次获取同一把锁，比如一个线程在执行一个带锁的方法，该方法中又调用了另一个需要相同锁的方法，则该线程可以直接执行调用的方法即可重入 ，而无需重新获得锁。像 Java 中的 <code>synchronized</code> 和 <code>ReentrantLock</code> 都属于可重入锁。</p><p><strong>不可重入的分布式锁基本可以满足绝大部分业务场景了，一些特殊的场景可能会需要使用可重入的分布式锁。</strong></p><p>可重入分布式锁的实现核心思路是线程在获取锁的时候判断是否为自己的锁，如果是的话，就不用再重新获取了。为此，我们可以为每个锁关联一个可重入计数器和一个占有它的线程。当可重入计数器大于 0 时，则锁被占有，需要判断占有该锁的线程和请求获取锁的线程是否为同一个。</p><p>实际项目中，我们不需要自己手动实现，推荐使用我们上面提到的 <strong>Redisson</strong> ，其内置了多种类型的锁比如可重入锁（Reentrant Lock）、自旋锁（Spin Lock）、公平锁（Fair Lock）、多重锁（MultiLock）、 红锁（RedLock）、 读写锁（ReadWriteLock）。</p><h2 id="Redis-如何解决集群情况下分布式锁的可靠性？"><a href="#Redis-如何解决集群情况下分布式锁的可靠性？" class="headerlink" title="Redis 如何解决集群情况下分布式锁的可靠性？"></a>Redis 如何解决集群情况下分布式锁的可靠性？</h2><p>为了避免单点故障，生产环境下的 Redis 服务通常是集群化部署的。</p><p>Redis 集群下，上面介绍到的分布式锁的实现会存在一些问题。由于 Redis 集群数据同步到各个节点时是异步的，如果在 Redis 主节点获取到锁后，在没有同步到其他节点时，Redis 主节点宕机了，此时新的 Redis 主节点依然可以获取锁，所以多个应用服务就可以同时获取到锁。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://miykah-imagebed.oss-cn-chengdu.aliyuncs.com/img/202305271941945.png"                      alt="image-20230316203737106"                ></p><p>针对这个问题，Redis 之父 antirez 设计了 <a class="link"   href="https://redis.io/topics/distlock" >Redlock 算法 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 来解决.</p><p>Redlock 算法的思想是让客户端向 Redis 集群中的多个独立的 Redis 实例依次请求申请加锁，如果客户端能够和半数以上的实例成功地完成加锁操作，那么我们就认为，客户端成功地获得分布式锁，否则加锁失败。</p><p>即使部分 Redis 节点出现问题，只要保证 Redis 集群中有半数以上的 Redis 节点可用，分布式锁服务就是正常的。</p><p>Redlock 是直接操作 Redis 节点的，并不是通过 Redis 集群操作的，这样才可以避免 Redis 集群主从切换导致的锁丢失问题。</p><p>Redlock 实现比较复杂，性能比较差，发生时钟变迁的情况下还存在安全性隐患。《数据密集型应用系统设计》一书的作者 Martin Kleppmann 曾经专门发文（<a class="link"   href="https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html" >How to do distributed locking - Martin Kleppmann - 2016 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>）怼过 Redlock，他认为这是一个很差的分布式锁实现。感兴趣的朋友可以看看<a class="link"   href="https://mp.weixin.qq.com/s?__biz=Mzg3NjU3NTkwMQ==&mid=2247505097&idx=1&sn=5c03cb769c4458350f4d4a321ad51f5a&source=41#wechat_redirect" >Redis 锁从面试连环炮聊到神仙打架 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>这篇文章，有详细介绍到 antirez 和 Martin Kleppmann 关于 Redlock 的激烈辩论。</p><p>实际项目中不建议使用 Redlock 算法，成本和收益不成正比。</p><p>如果不是非要实现绝对可靠的分布式锁的话，其实单机版 Redis 就完全够了，实现简单，性能也非常高。如果你必须要实现一个绝对可靠的分布式锁的话，可以基于 ZooKeeper 来做，只是性能会差一些。</p><h1 id="基于-ZooKeeper-实现分布式锁"><a href="#基于-ZooKeeper-实现分布式锁" class="headerlink" title="基于 ZooKeeper 实现分布式锁"></a>基于 ZooKeeper 实现分布式锁</h1><blockquote><p>Redis 实现分布式锁性能较高，ZooKeeper 实现分布式锁可靠性更高。实际项目中，我们应该根据业务的具体需求来选择。</p><p>个人理解，Redis集群的情况下，可能会出现A客户端在Redis主节点获得锁，然后还没有同步其他节点时，主节点宕机，选举新的主节点，这种情况下B客户端可以从新的主节点获取锁。</p><p>而Zookeeper是保证一致性的，所以不会出现这种问题。</p></blockquote><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://miykah-imagebed.oss-cn-chengdu.aliyuncs.com/img/202305271941962.png"                      alt="image-20230418154847387"                ></p><h2 id="如何基于-ZooKeeper-实现分布式锁？"><a href="#如何基于-ZooKeeper-实现分布式锁？" class="headerlink" title="如何基于 ZooKeeper 实现分布式锁？"></a>如何基于 ZooKeeper 实现分布式锁？</h2><p>ZooKeeper 分布式锁是基于 <strong>临时顺序节点</strong> 和 <strong>Watcher（事件监听器）</strong> 实现的。</p><p>获取锁：</p><ol><li>首先我们要有一个持久节点<code>/locks</code>，客户端获取锁就是在<code>locks</code>下创建临时顺序节点。</li><li>假设客户端 1 创建了<code>/locks/lock1</code>节点，创建成功之后，会判断 <code>lock1</code>是否是 <code>/locks</code> 下最小的子节点。</li><li>如果 <code>lock1</code>是最小的子节点，则获取锁成功。否则，获取锁失败。</li><li>如果获取锁失败，则说明有其他的客户端已经成功获取锁。客户端 1 并不会不停地循环去尝试加锁，而是在前一个节点比如<code>/locks/lock0</code>上注册一个事件监听器。这个监听器的作用是当前一个节点释放锁之后通知客户端 1（避免无效自旋），这样客户端 1 就加锁成功了。</li></ol><p>释放锁：</p><ol><li>成功获取锁的客户端在执行完业务流程之后，会将对应的子节点删除。</li><li>成功获取锁的客户端在出现故障之后，对应的子节点由于是临时顺序节点（会话结束临时节点就会被删除），也会被自动删除，避免了锁无法被释放。</li><li>我们前面说的事件监听器其实监听的就是这个子节点删除事件，子节点删除就意味着锁被释放。</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://miykah-imagebed.oss-cn-chengdu.aliyuncs.com/img/202305271941887.png"                      alt="img"                ></p><p>实际项目中，推荐使用 Curator 来实现 ZooKeeper 分布式锁。Curator 是 Netflix 公司开源的一套 ZooKeeper Java 客户端框架，相比于 ZooKeeper 自带的客户端 zookeeper 来说，Curator 的封装更加完善，各种 API 都可以比较方便地使用。</p><p><code>Curator</code>主要实现了下面四种锁：</p><ul><li><code>InterProcessMutex</code>：分布式可重入排它锁</li><li><code>InterProcessSemaphoreMutex</code>：分布式不可重入排它锁</li><li><code>InterProcessReadWriteLock</code>：分布式读写锁</li><li><code>InterProcessMultiLock</code>：将多个锁作为单个实体管理的容器，获取锁的时候获取所有锁，释放锁也会释放所有锁资源（忽略释放失败的锁）。</li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CuratorFramework</span> <span class="variable">client</span> <span class="operator">=</span> ZKUtils.getClient();</span><br><span class="line">client.start();</span><br><span class="line"><span class="comment">// 分布式可重入排它锁</span></span><br><span class="line"><span class="type">InterProcessLock</span> <span class="variable">lock1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterProcessMutex</span>(client, lockPath1);</span><br><span class="line"><span class="comment">// 分布式不可重入排它锁</span></span><br><span class="line"><span class="type">InterProcessLock</span> <span class="variable">lock2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterProcessSemaphoreMutex</span>(client, lockPath2);</span><br><span class="line"><span class="comment">// 将多个锁作为一个整体</span></span><br><span class="line"><span class="type">InterProcessMultiLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterProcessMultiLock</span>(Arrays.asList(lock1, lock2));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!lock.acquire(<span class="number">10</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;不能获取多锁&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;已获取多锁&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;是否有第一个锁: &quot;</span> + lock1.isAcquiredInThisProcess());</span><br><span class="line">System.out.println(<span class="string">&quot;是否有第二个锁: &quot;</span> + lock2.isAcquiredInThisProcess());</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 资源操作</span></span><br><span class="line">  resource.use(); </span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;释放多个锁&quot;</span>);</span><br><span class="line">    lock.release(); </span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;是否有第一个锁: &quot;</span> + lock1.isAcquiredInThisProcess());</span><br><span class="line">System.out.println(<span class="string">&quot;是否有第二个锁: &quot;</span> + lock2.isAcquiredInThisProcess());</span><br><span class="line">client.close();</span><br></pre></td></tr></table></figure></div><h2 id="为什么要用临时顺序节点？"><a href="#为什么要用临时顺序节点？" class="headerlink" title="为什么要用临时顺序节点？"></a>为什么要用临时顺序节点？</h2><p>每个数据节点在 ZooKeeper 中被称为 <strong>znode</strong>，它是 ZooKeeper 中数据的最小单元。</p><p>我们通常是将 znode 分为 4 大类：</p><ul><li><strong>持久（PERSISTENT）节点</strong> ：一旦创建就一直存在即使 ZooKeeper 集群宕机，直到将其删除。</li><li><strong>临时（EPHEMERAL）节点</strong> ：临时节点的生命周期是与 <strong>客户端会话（session）</strong> 绑定的，<strong>会话消失则节点消失</strong> 。并且，<strong>临时节点只能做叶子节点</strong> ，不能创建子节点。</li><li><strong>持久顺序（PERSISTENT_SEQUENTIAL）节点</strong> ：除了具有持久（PERSISTENT）节点的特性之外， 子节点的名称还具有顺序性。比如 <code>/node1/app0000000001</code> 、<code>/node1/app0000000002</code> 。</li><li><strong>临时顺序（EPHEMERAL_SEQUENTIAL）节点</strong> ：除了具备临时（EPHEMERAL）节点的特性之外，子节点的名称还具有顺序性。</li></ul><p>可以看出，临时节点相比持久节点，最主要的是对会话失效的情况处理不一样，临时节点会话消失则对应的节点消失。这样的话，如果客户端发生异常导致没来得及释放锁也没关系，会话失效节点自动被删除，不会发生死锁的问题。</p><p>使用 Redis 实现分布式锁的时候，我们是通过过期时间来避免锁无法被释放导致死锁问题的，而 ZooKeeper 直接利用临时节点的特性即可。</p><p>假设不使用顺序节点的话，所有尝试获取锁的客户端都会对持有锁的子节点加监听器。当该锁被释放之后，势必会造成所有尝试获取锁的客户端来争夺锁，这样对性能不友好。使用顺序节点之后，只需要监听前一个节点就好了，对性能更友好。</p><h2 id="为什么要设置对前一个节点的监听？"><a href="#为什么要设置对前一个节点的监听？" class="headerlink" title="为什么要设置对前一个节点的监听？"></a>为什么要设置对前一个节点的监听？</h2><blockquote><p>Watcher（事件监听器），是 ZooKeeper 中的一个很重要的特性。ZooKeeper 允许用户在指定节点上注册一些 Watcher，并且在一些特定事件触发的时候，ZooKeeper 服务端会将事件通知到感兴趣的客户端上去，该机制是 ZooKeeper 实现分布式协调服务的重要特性。</p></blockquote><p>同一时间段内，可能会有很多客户端同时获取锁，但只有一个可以获取成功。如果获取锁失败，则说明有其他的客户端已经成功获取锁。获取锁失败的客户端并不会不停地循环去尝试加锁，而是在前一个节点注册一个事件监听器。</p><p>这个事件监听器的作用是： <strong>当前一个节点对应的客户端释放锁之后（也就是前一个节点被删除之后，监听的是删除事件），通知获取锁失败的客户端（唤醒等待的线程，Java 中的 <code>wait/notifyAll</code> ），让它尝试去获取锁，然后就成功获取锁了。</strong></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这篇文章我们介绍了分布式锁的基本概念以及实现分布式锁的两种常见方式。至于具体选择 Redis 还是 ZooKeeper 来实现分布式锁，还是要看业务的具体需求。如果对性能要求比较高的话，建议使用 Redis 实现分布式锁。如果对可靠性要求比较高的话，建议使用 ZooKeeper 实现分布式锁。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文源自 &lt;a class=&quot;link&quot;   href=&quot;https://javaguide.cn/&quot; &gt;https://javaguide.cn/ &lt;i class=&quot;fa-regular fa-arrow-up-right-from-squar</summary>
      
    
    
    
    <category term="Java" scheme="https://miykah.top/categories/Java/"/>
    
    <category term="分布式" scheme="https://miykah.top/categories/Java/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="分布式锁" scheme="https://miykah.top/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    
    <category term="Redis" scheme="https://miykah.top/tags/Redis/"/>
    
    <category term="ZooKeeper" scheme="https://miykah.top/tags/ZooKeeper/"/>
    
  </entry>
  
  <entry>
    <title>Hexo配置Waline评论系统</title>
    <link href="https://miykah.top/2023/05/27/Hexo%E9%85%8D%E7%BD%AEWaline%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/"/>
    <id>https://miykah.top/2023/05/27/Hexo%E9%85%8D%E7%BD%AEWaline%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/</id>
    <published>2023-05-27T03:33:08.000Z</published>
    <updated>2023-05-28T07:36:55.585Z</updated>
    
    <content type="html"><![CDATA[<h1 id="评论系统选择"><a href="#评论系统选择" class="headerlink" title="评论系统选择"></a>评论系统选择</h1><p>Waline 是一款简洁、安全的评论系统。</p><p>具有管理评论和Reaction的功能。如图：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://miykah-imagebed.oss-cn-chengdu.aliyuncs.com/img/202305271203229.png"                      alt="image-20230527113844370"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://miykah-imagebed.oss-cn-chengdu.aliyuncs.com/img/202305271203220.png"                      alt="image-20230527113851143"                ></p><h1 id="Hexo-Keep主题配置Waline评论系统"><a href="#Hexo-Keep主题配置Waline评论系统" class="headerlink" title="Hexo-Keep主题配置Waline评论系统"></a>Hexo-Keep主题配置Waline评论系统</h1><h2 id="根据-Waline-文档部署-LeanCloud-数据库和-Vercel-服务端"><a href="#根据-Waline-文档部署-LeanCloud-数据库和-Vercel-服务端" class="headerlink" title="根据 Waline 文档部署 LeanCloud 数据库和 Vercel 服务端"></a>根据 Waline 文档部署 LeanCloud 数据库和 Vercel 服务端</h2><p><a class="link"   href="https://waline.js.org/guide/get-started/" >https://waline.js.org/guide/get-started/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><h2 id="修改主题配置文件-config-yml"><a href="#修改主题配置文件-config-yml" class="headerlink" title="修改主题配置文件 _config.yml"></a>修改主题配置文件 _config.yml</h2><ol><li><p>启用评论，并使用 waline 评论系统</p><div class="highlight-container" data-rel="Yml"><figure class="iseeu highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">comment:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>   <span class="comment"># Option values: true | false</span></span><br><span class="line">  <span class="attr">use:</span> <span class="string">waline</span>     <span class="comment"># Option values: valine | gitalk | twikoo | waline</span></span><br></pre></td></tr></table></figure></div></li><li><p>配置 waline</p><p><code>server_url</code> 是成功部署 Waline 评论系统的服务端地址。</p><p><code>reaction</code> 设置开启文章反应，可选值：<code>true</code> 或 <code>false</code>。</p><p><code>version</code> 设置 Waline 评论系统版本，Keep 主题内置使用 Waline <code>v2</code>，你可以自行更改。</p><div class="highlight-container" data-rel="Yml"><figure class="iseeu highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">waline:</span></span><br><span class="line">  <span class="attr">server_url:</span> <span class="string">https://comment-waline-server-qk96wik8t-miykah.vercel.app/</span> <span class="comment"># Server URL</span></span><br><span class="line">  <span class="attr">reaction:</span> <span class="literal">true</span> <span class="comment"># Article reactions, Option values: true | false</span></span><br><span class="line">  <span class="attr">version:</span> <span class="number">2</span>      <span class="comment"># Waline version, default use v2</span></span><br></pre></td></tr></table></figure></div></li><li><p>评论系统启用成功</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://miykah-imagebed.oss-cn-chengdu.aliyuncs.com/img/202305271203226.png"                      alt="image-20230527114452740"                ></p></li></ol><h1 id="评论系统与管理系统"><a href="#评论系统与管理系统" class="headerlink" title="评论系统与管理系统"></a>评论系统与管理系统</h1><blockquote><p>评论系统：example.yourdomain.com      我的：<a class="link"   href="https://comment.miykah.top/" >https://comment.miykah.top/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>评论管理：example.yourdomain.com&#x2F;ui   我的：<a class="link"   href="https://comment.miykah.top/ui" >https://comment.miykah.top/ui <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></blockquote><p>评论管理系统可以进行评论管理以及用户管理：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://miykah-imagebed.oss-cn-chengdu.aliyuncs.com/img/202305271212151.png"                      alt="image-202305271212151"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://miykah-imagebed.oss-cn-chengdu.aliyuncs.com/img/202305271203209.png"                      alt="image-20230527120150930"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://miykah-imagebed.oss-cn-chengdu.aliyuncs.com/img/202305271203203.png"                      alt="image-20230527120159505"                ></p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="只有在挂了梯子之后才能流畅访问"><a href="#只有在挂了梯子之后才能流畅访问" class="headerlink" title="只有在挂了梯子之后才能流畅访问"></a>只有在挂了梯子之后才能流畅访问</h2><blockquote><p>不连接梯子的情况下， 博客的评论一直加载不出来，百度了一下，发现是 vercel.app 的域名问题。</p><p><a class="link"   href="https://blog.csdn.net/Panzer_Jack/article/details/127418379" >https://blog.csdn.net/Panzer_Jack/article/details/127418379 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></blockquote><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><blockquote><p>参考：</p><p><a class="link"   href="https://blog.csdn.net/Panzer_Jack/article/details/127418379" >https://blog.csdn.net/Panzer_Jack/article/details/127418379 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p><a class="link"   href="https://waline.js.org/guide/get-started/#%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D-%E5%8F%AF%E9%80%89" >https://waline.js.org/guide/get-started/#%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D-%E5%8F%AF%E9%80%89 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></blockquote><ol><li><p>首先需要有一个域名，比如我有一个 <code>miykah.top</code> 域名</p></li><li><p>域名解析添加记录：取一个二级域名为 <code>comment</code> ，记录值为 <code>cname.vercel-dns.com</code> </p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://miykah-imagebed.oss-cn-chengdu.aliyuncs.com/img/202305271203402.png"                      alt="image-20230527114655250"                ></p></li><li><p>在vercel部署的服务端中绑定域名 <code>comment.miykah.top</code></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://miykah-imagebed.oss-cn-chengdu.aliyuncs.com/img/202305271203436.png"                      alt="image-20230527114805551"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://miykah-imagebed.oss-cn-chengdu.aliyuncs.com/img/202305271203465.png"                      alt="image-20230527114832215"                ></p></li><li><p>修改主题配置文件 _config.yml</p><div class="highlight-container" data-rel="Yml"><figure class="iseeu highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">waline:</span></span><br><span class="line">  <span class="attr">server_url:</span> <span class="string">https://comment.miykah.top/</span> <span class="comment"># 改为绑定的评论系统新域名</span></span><br><span class="line">  <span class="attr">reaction:</span> <span class="literal">true</span> <span class="comment"># Article reactions, Option values: true | false</span></span><br><span class="line">  <span class="attr">version:</span> <span class="number">2</span>      <span class="comment"># Waline version, default use v2</span></span><br></pre></td></tr></table></figure></div></li><li><p>问题解决！不挂梯子也能加载出评论！</p></li></ol><h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><h2 id="配置邮件通知"><a href="#配置邮件通知" class="headerlink" title="配置邮件通知"></a>配置邮件通知</h2><p>参考：</p><p><a class="link"   href="https://waline.js.org/guide/features/notification.html#%E9%82%AE%E4%BB%B6%E9%80%9A%E7%9F%A5" >https://waline.js.org/guide/features/notification.html#%E9%82%AE%E4%BB%B6%E9%80%9A%E7%9F%A5 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p><a class="link"   href="https://oragekk.me/blog/waline-mail.html" >https://oragekk.me/blog/waline-mail.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;评论系统选择&quot;&gt;&lt;a href=&quot;#评论系统选择&quot; class=&quot;headerlink&quot; title=&quot;评论系统选择&quot;&gt;&lt;/a&gt;评论系统选择&lt;/h1&gt;&lt;p&gt;Waline 是一款简洁、安全的评论系统。&lt;/p&gt;
&lt;p&gt;具有管理评论和Reaction的功能。如图：&lt;/p</summary>
      
    
    
    
    <category term="博客搭建" scheme="https://miykah.top/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
    <category term="waline" scheme="https://miykah.top/tags/waline/"/>
    
    <category term="Hexo" scheme="https://miykah.top/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>项目部署到云服务器后漏洞修复</title>
    <link href="https://miykah.top/2023/05/26/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%88%B0%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%8E%E6%BC%8F%E6%B4%9E%E4%BF%AE%E5%A4%8D/"/>
    <id>https://miykah.top/2023/05/26/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%88%B0%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%8E%E6%BC%8F%E6%B4%9E%E4%BF%AE%E5%A4%8D/</id>
    <published>2023-05-26T06:12:08.000Z</published>
    <updated>2023-05-28T07:36:55.589Z</updated>
    
    <content type="html"><![CDATA[<p>部署到云服务器之后，发现有5个安全漏洞。</p><p>需要根据修复方案自行修复</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://miykah-imagebed.oss-cn-chengdu.aliyuncs.com/img/202305261419806.png"                      alt="image-20230526141902762"                ></p><span id="more"></span><h1 id="Apache-Dubbo-漏洞修复"><a href="#Apache-Dubbo-漏洞修复" class="headerlink" title="Apache Dubbo 漏洞修复"></a>Apache Dubbo 漏洞修复</h1><p>将 Apache Dubbo 3.0.9 升级到 3.0.14 及以上版本</p><div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- dubbo --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.dubbo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.14<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div><h1 id="FasterXML-jackson-databind-漏洞修复"><a href="#FasterXML-jackson-databind-漏洞修复" class="headerlink" title="FasterXML jackson-databind 漏洞修复"></a>FasterXML jackson-databind 漏洞修复</h1><p>查看 Maven 依赖发现是 Nacos 依赖了 FasterXML jackson-databind 2.13.3。</p><p>需要排除掉 Nacos 中的 jackson-databind 和 jackson-core 2.13.3 依赖，自己引入 2.14.0 以上版本</p><div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- nacos 注册中心 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.nacos<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>nacos-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 排除掉nacos依赖的有高危漏洞的2.13jackson，自己引入 2.14.0以上的  --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.14.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div><h1 id="Spring-Framework-身份认证绕过漏洞"><a href="#Spring-Framework-身份认证绕过漏洞" class="headerlink" title="Spring Framework 身份认证绕过漏洞"></a><strong>Spring Framework 身份认证绕过漏洞</strong></h1><p>发现是 spring-webmvc-5.3.20 的问题，查看 Maven 依赖，是 spring-boot-starter-web:2.7.0 引入。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://miykah-imagebed.oss-cn-chengdu.aliyuncs.com/img/202305261420214.png"                      alt="image-20230526142002186"                ></p><p>直接将项目的 spring boot 版本升级到 2.7.11</p><div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure></div><p>但升级之后下载不到 mysql-connector-java 的 jar包，因为我们没有指定版本。</p><p>手动指定 mysql-connector-java 的版本即可解决</p><div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- mysql--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--为了修复Spring Framework漏洞 将Spring boot版本升到2.7.11后，</span></span><br><span class="line"><span class="comment">  mysql-connector-java 找不到，只能指定版本--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.31<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;部署到云服务器之后，发现有5个安全漏洞。&lt;/p&gt;
&lt;p&gt;需要根据修复方案自行修复&lt;/p&gt;
&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;https://miykah-imagebed.oss-cn-chengdu.aliyuncs.com/img/202305261419806.png&quot;
                      alt=&quot;image-20230526141902762&quot;
                &gt;&lt;/p&gt;</summary>
    
    
    
    <category term="项目" scheme="https://miykah.top/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="项目部署" scheme="https://miykah.top/tags/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/"/>
    
    <category term="云服务器" scheme="https://miykah.top/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>自定义注解+AOP实现权限管理</title>
    <link href="https://miykah.top/2023/05/26/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3+AOP%E5%AE%9E%E7%8E%B0%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/"/>
    <id>https://miykah.top/2023/05/26/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3+AOP%E5%AE%9E%E7%8E%B0%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</id>
    <published>2023-05-26T05:42:11.000Z</published>
    <updated>2023-05-28T07:36:55.588Z</updated>
    
    <content type="html"><![CDATA[<p>本文使用自定义注解和AOP面向切面编程实现权限管理。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://miykah-imagebed.oss-cn-chengdu.aliyuncs.com/img/202305261345742.png"                      alt="image-20230526134510324"                ></p><span id="more"></span><h1 id="权限管理注解-AuthCheck-及-AOP"><a href="#权限管理注解-AuthCheck-及-AOP" class="headerlink" title="权限管理注解 @AuthCheck 及 AOP"></a>权限管理注解 <code>@AuthCheck</code> 及 AOP</h1><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>在需要校验权限的方法（控制器方法）上，加上 <code>@AuthCheck</code> 注解并指定该方法需要什么角色才能访问。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://miykah-imagebed.oss-cn-chengdu.aliyuncs.com/img/202305261345343.png"                      alt="image-20230526134510324"                ></p><p>如果没有权限进行操作，就会抛出异常。</p><p>比如：</p><ul><li>在方法上使用注解（anyRole)</li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AuthCheck(anyRole = &#123;&quot;admin&quot;, &quot;user&quot;&#125;)</span></span><br></pre></td></tr></table></figure></div><p>最终在<code>AuthInterceptor</code>中，会校验，如果当前登录用户是 anyRole 数组中任一角色，即可访问被这个注解注解的方法。</p><ul><li>在方法上使用注解（mustRole)</li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AuthCheck(mustRole = &quot;admin&quot;)</span></span><br></pre></td></tr></table></figure></div><p>最终在<code>AuthInterceptor</code>中，会校验，如果当前登录用户是 mustRole 指定的角色，即可访问被这个注解注解的方法。</p><h2 id="源码学习"><a href="#源码学习" class="headerlink" title="源码学习"></a>源码学习</h2><h3 id="AuthCheck-注解"><a href="#AuthCheck-注解" class="headerlink" title="AuthCheck 注解"></a>AuthCheck 注解</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AuthCheck &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有任何一个角色</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] anyRole() <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 必须有某个角色</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">mustRole</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a class="link"   href="https://zhuanlan.zhihu.com/p/60730622" >一篇文章，全面掌握Java自定义注解（Annontation） <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><h4 id="注解的定义"><a href="#注解的定义" class="headerlink" title="注解的定义"></a>注解的定义</h4><ul><li>注解的定义通过@interface表示，所有的注解会自动继承java.lang.Annotation接口,且不能再继承别的类或是接口。</li><li>注解的成员参数只能用public或默认(default) 访问权修饰来进行修饰。</li><li>成员参数只能使用八种基本类型（byte、short、char、int、long、float、double、boolean）和String、Enum、Class、annotations等数据类型，及其数组。</li><li>获取类方法和字段的注解信息，只能通过Java的反射技术来获取 Annotation 对象。</li><li>注解可以没有定义成员，只做标识。</li></ul><h4 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h4><p><code>**@Target**</code><strong>和</strong><code>**@Retention**</code><strong>是元注解（注解其他注解的注解）</strong></p><ul><li>@Documented – 注解是否将包含在JavaDoc中</li><li>@Retention – 注解的生命周期</li><li>@Target – 注解用于什么地方</li><li>@Inherited – 是否允许子类继承该注解</li><li>@Repeatable - 是否可重复注解，jdk1.8引入</li></ul><h4 id="注解的生命周期"><a href="#注解的生命周期" class="headerlink" title="注解的生命周期"></a>注解的生命周期</h4><p>通过@Retention定义注解的生命周期，格式如下：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Retention(RetentionPolicy.SOURCE)</span><br></pre></td></tr></table></figure></div><p>其中RetentionPolicy的不同策略对应的生命周期如下：</p><ul><li>RetentionPolicy.SOURCE : 仅存在于源代码中，编译阶段会被丢弃，不会包含于class字节码文件中。@Override, @SuppressWarnings都属于这类注解。</li><li>RetentionPolicy.CLASS : 默认策略，在class字节码文件中存在，在类加载的时被丢弃，运行时无法获取到。</li><li>RetentionPolicy.RUNTIME : 始终不会丢弃，可以使用反射获得该注解的信息。<strong>自定义的注解最常用的使用方式。</strong></li></ul><h4 id="注解的作用目标"><a href="#注解的作用目标" class="headerlink" title="注解的作用目标"></a>注解的作用目标</h4><p>通过@Target定义注解作用的目标，比如作用于类、属性、或方法等，默认可用于任何地方。格式如下：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Target(ElementType.TYPE)</span><br></pre></td></tr></table></figure></div><p>对应ElementType参数值适用范围如下：</p><ul><li>ElementType.TYPE: 类、接口、注解、enum</li><li>ElementType.CONSTRUCTOR: 构造函数</li><li>ElementType.FIELD: 成员变量、对象、属性、枚举的常量</li><li>ElementType.LOCAL_VARIABLE: 局部变量</li><li>ElementType.METHOD: 方法</li><li>ElementType.PACKAGE: 包</li><li>ElementType.PARAMETER: 参数</li><li>ElementType.ANNOTATION_TYPE): 注解</li><li>ElementType.TYPE_PARAMETER：类型参数，表示这个注解可以用在 Type的声明式前,jdk1.8引入。</li><li>ElementType.TYPE_USE：类型的注解，表示这个注解可以用在所有使用Type的地方（如：泛型，类型转换等），jdk1.8引入。</li></ul><h3 id="AOP-实现权限管理拦截器"><a href="#AOP-实现权限管理拦截器" class="headerlink" title="AOP 实现权限管理拦截器"></a>AOP 实现权限管理拦截器</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行拦截</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> authCheck</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Around(&quot;@annotation(authCheck)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">doInterceptor</span><span class="params">(ProceedingJoinPoint joinPoint, AuthCheck authCheck)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 获取注解的 anyRole数组, 将其转换为 List</span></span><br><span class="line">        List&lt;String&gt; anyRole = Arrays.stream(authCheck.anyRole()).filter(StringUtils::isNotBlank).collect(Collectors.toList());</span><br><span class="line">        <span class="comment">// 获取注解的 mustRole</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">mustRole</span> <span class="operator">=</span> authCheck.mustRole();</span><br><span class="line">        <span class="comment">// 获取当前登录用户</span></span><br><span class="line">        <span class="type">RequestAttributes</span> <span class="variable">requestAttributes</span> <span class="operator">=</span> RequestContextHolder.currentRequestAttributes();</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> ((ServletRequestAttributes) requestAttributes).getRequest();</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.getLoginUser(request);</span><br><span class="line">        <span class="comment">// 拥有anyRole中任意权限即通过</span></span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isNotEmpty(anyRole)) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">userRole</span> <span class="operator">=</span> user.getUserRole();</span><br><span class="line">            <span class="keyword">if</span> (!anyRole.contains(userRole)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(ErrorCode.NO_AUTH_ERROR);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 必须有所有权限才通过</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotBlank(mustRole)) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">userRole</span> <span class="operator">=</span> user.getUserRole();</span><br><span class="line">            <span class="keyword">if</span> (!mustRole.equals(userRole)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(ErrorCode.NO_AUTH_ERROR);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 通过权限校验，放行</span></span><br><span class="line">        <span class="keyword">return</span> joinPoint.proceed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>数据库 user 表中，有一个 varChar 类型的 userRole 字段。</p><p>更完善的权限管理方法，应该使用 RBAC 模型，即数据库要有 权限表、角色表、用户表、角色权限表、用户角色表。而鱼皮这里只是简单使用一个字段表示用户角色。</p><p>完美的方案参考：</p><p><a class="link"   href="https://blog.csdn.net/byteArr/article/details/103984725" >springboot+自定义注解+AOP实现权限控制（一） <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p><a class="link"   href="https://blog.csdn.net/byteArr/article/details/103992016" >springboot+自定义注解+AOP实现权限控制（二） <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文使用自定义注解和AOP面向切面编程实现权限管理。&lt;/p&gt;
&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;https://miykah-imagebed.oss-cn-chengdu.aliyuncs.com/img/202305261345742.png&quot;
                      alt=&quot;image-20230526134510324&quot;
                &gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://miykah.top/categories/Java/"/>
    
    
    <category term="注解" scheme="https://miykah.top/tags/%E6%B3%A8%E8%A7%A3/"/>
    
    <category term="AOP" scheme="https://miykah.top/tags/AOP/"/>
    
  </entry>
  
</feed>
